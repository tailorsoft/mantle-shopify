<?xml version="1.0" encoding="UTF-8"?>
<services xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="http://moqui.org/xsd/service-definition-2.1.xsd">
	<!-- 
        Endpoint to pull down orders from Shopify.

        https://{store_name}.myshopify.com/admin/api/2023-04/orders.json?limit={limit}&fulfillment_status={status}&since_id={order_id}
    -->
    <service verb="download" noun="ShopifyOrders">
        <in-parameters>
            <parameter name="systemMessageRemoteId" required="true"/>
            <parameter name="fulfillmentStatus" default-value="unfulfilled"/>
            <parameter name="limit" default-value="250"/>
        </in-parameters>
        <out-parameters>
            <parameter name="systemMessageId"/>
        </out-parameters>
        <actions>
            <script>import groovy.json.JsonSlurper</script>
            <entity-find-one entity-name="moqui.service.message.SystemMessageRemote" value-field="remote">
                <field-map field-name="systemMessageTypeId" value="ShopifySystemMessageType"/>
                <field-map field-name="systemMessageRemoteId"/>
            </entity-find-one>

            <if condition="!remote"><return error="true" message="No Remote of type 'ShopifySystemMessageType' found for ID ${systemMessageRemoteId}"/></if>

            <!-- see if we have called this before and what was the last order found on previous message -->
            <entity-find entity-name="moqui.service.message.SystemMessage" limit="1" list="prevMessages">
                <econdition field-name="systemMessageTypeId" value='ShopifySystemMessageType'/>
                <econdition field-name="systemMessageRemoteId"/>
                <econdition field-name="docType" value="orderList"/>
                <order-by field-name="initDate"/>
            </entity-find>
            <set field="lastOrderId" from="prevMessages ? prevMessages.first().docControl : null"/>

            <!-- https://{hostname}/admin/api/{version}/{resource}.json?limit=250&fulfillment_status=unfulfilled&since_id={last} -->
            <script><![CDATA[
                String url = ec.resource.expand(remote.sendUrl, "", [resource:"orders"]) +
                    "?limit=${limit}&fulfillment_status=${fulfillmentStatus}";

                if (lastOrderId != null) {
                    url += "&since_id=${lastOrderId}";
                }

                org.moqui.util.RestClient restClient = ec.service.rest().method("GET")
                    .addHeader("Content-Type", "application/json")
                    .basicAuth(remote.username, remote.password)
                    .uri(url);

                org.moqui.util.RestClient.RestResponse restResponse = restClient.call()

                if (restResponse.statusCode != 200) {
                    ec.logger.error("Shopify Orders API Response ${restResponse.statusCode} ${restResponse.reasonPhrase}: ${restResponse.text()} for url: ${url}")
                    return
                }
                Map messageMap = new JsonSlurper().parseText(restResponse.text());
                lastOrderId = messageMap.orders ? messageMap.orders.last().id : null;
            ]]></script>

            <if condition="lastOrderId">
                <service-call name="create#moqui.service.message.SystemMessage" out-map="context" in-map="[
                    systemMessageTypeId:'ShopifySystemMessageType', systemMessageRemoteId:systemMessageRemoteId,
                    messageText:restResponse.text(), docType:'orders', docControl:lastOrderId,
                    isOutgoing:'N', initDate:ec.user.nowTimestamp, statusId:'SmsgReceived']"/>
            </if>
        </actions>
    </service>


    <!-- consume the list of orders and generate individual system messages -->
    <service verb="consume" noun="OrderListSystemMessage">
        <implements service="org.moqui.impl.SystemMessageServices.consume#SystemMessage"/>
        <actions>
            <script>
                import groovy.json.JsonSlurper;
                import groovy.json.JsonOutput;
            </script>
            <entity-find-one entity-name="moqui.service.message.SystemMessage" value-field="systemMessage"/>
            <set field="messageMap" from="new JsonSlurper().parseText(systemMessage.messageText)"/>

             <entity-find-one entity-name="moqui.service.message.SystemMessageRemote" value-field="remote">
                <field-map field-name="systemMessageTypeId" value="ShopifySystemMessageType"/>
                <field-map field-name="systemMessageRemoteId" from="systemMessage.systemMessageRemoteId"/>
            </entity-find-one>

            <iterate list="messageMap.orders" entry="order">
                <service-call name="mantle.shopify.ShopifyOrderServices.download#ShopifyFulfillmentOrders" out-map="context"
                                in-map="[systemMessageRemoteId:systemMessage.systemMessageRemoteId, shopifyOrderId:order.id]"/>

                <service-call name="create#moqui.service.message.SystemMessage" out-map="context"
                                in-map="[systemMessageTypeId:'ShopifySystemMessageType', 
                                parentMessageId: systemMessage.systemMessageId,
                                messageText:JsonOutput.toJson([order:order, fulfillment_orders:fulfillmentOrders]), docType:'order',
                                isOutgoing:'N', initDate:ec.user.nowTimestamp, statusId:'SmsgReceived']"/>

                <!-- immediately try to consume the order message -->
                <service-call name="org.moqui.impl.SystemMessageServices.consume#ReceivedSystemMessage"
                    in-map="[systemMessageId:systemMessageId, allowError:false]" async="true"/>
            </iterate>
        </actions>
    </service>


    <service verb="download" noun="ShopifyFulfillmentOrders">
        <in-parameters>
            <parameter name="systemMessageRemoteId" required="true"/>
            <parameter name="shopifyOrderId" required="true"/>
        </in-parameters>
        <out-parameters>
            <parameter name="fulfillmentOrders" type="List" />
        </out-parameters>
        <actions>
            <entity-find-one entity-name="moqui.service.message.SystemMessageRemote" value-field="remote"/>
            <set field="fulfillmentOrders" from="[]"/>
            <script><![CDATA[
                // https://your-development-store.myshopify.com/admin/api/2023-04/orders/450789469/fulfillment_orders.json
                String url = ec.resource.expand(remote.sendUrl, "", [resource: "/orders/${shopifyOrderId}/fulfillment_orders"]);
                org.moqui.util.RestClient.RestResponse restResponse = ec.service.rest().method("GET")
                    .addHeader("X-Shopify-Access-Token", remote.password).uri(url).call();

                if (restResponse.statusCode != 200) {
                    ec.message.addError("Shopify Orders API Response ${restResponse.statusCode} ${restResponse.reasonPhrase}: ${restResponse.text()} url:${url}")
                    return;
                }
                Map responseMap = new groovy.json.JsonSlurper().parseText(restResponse.text());
                fulfillmentOrders = responseMap.fulfillment_orders;
            ]]></script>
        </actions>
    </service>


    <!-- consume order-->
    <service verb="consume" noun="OrderSystemMessage">
        <implements service="org.moqui.impl.SystemMessageServices.consume#SystemMessage"/>
        <actions>
            <entity-find-one entity-name="moqui.service.message.SystemMessage" value-field="systemMessage" for-update="true"/>

            <entity-find-one entity-name="moqui.service.message.SystemMessageRemote" value-field="systemMessageRemote">
                <field-map field-name="systemMessageTypeId" from="systemMessage.systemMessageTypeId"/>
            </entity-find-one>

            <set field="messageMap" from="new groovy.json.JsonSlurper().parseText(systemMessage.messageText)"/>

            <service-call name="mantle.shopify.ApiServices.consume#ShopifyOrderMap"
                    in-map="[order:messageMap.order, productStoreId:systemMessageRemote.productStoreId]" out-map="context"/>

            <!-- not sure what to do with orders that are missing the fulfillment message -->
            <if condition="messageMap.fulfillment_orders">
                <service-call name="mantle.shopify.ShopifyOrderServices.create#ShopifyFulfillmentOrders"
                    in-map="[fulfillments:messageMap.fulfillment_orders, orderId:orderId]"/>
            </if>

            <set field="systemMessage.orderId" from="orderId"/>
            <entity-update value-field="systemMessage"/>
        </actions>
    </service>

    <service verb="create" noun="ShopifyFulfillmentOrders">
        <in-parameters>
            <parameter name="orderId" required="true"/>
            <parameter name="fulfillmentOrders" type="List"/>
        </in-parameters>
        <actions>
            <iterate list="fulfillmentOrders" entry="fulfillment_order">
                <entity-find-one entity-name="mantle.order.OrderHeader" value-field="order">
                    <field-map field-name="externalId" from="fulfillment_order.order_id"/>
                </entity-find-one>

                <service-call name="create#mantle.shopify.ShopifyFulfillmentOrder" out-map="context"
                    in-map="[fulfillmentOrderId:fulfillment_order.id, orderId:orderId, status:fulfillment_order.status, locationId:assigned_location_id]"/>

                <!-- Get Fulfillment order line items Id -->
                <entity-find entity-name="mantle.order.OrderItem" list="orderItems" for-update="true">
                    <econdition field-name="orderId" from="order.orderId"/>
                    <econdition field-name="sourceReferenceId" operator="is-not-null"/>
                </entity-find>
                <iterate list="orderItems" entry="orderItem">
                    <set field="lineItem" from="fulfillment_order.line_items.find{(String)it.line_item_id == orderItem.sourceReferenceId}"/>
                    <if condition="!lineItem">
                        <log warn="No fulfillment order line item found for OrderItem: ${orderItem.orderItemSeqId}"/>
                        <continue/>
                    </if>
                    <set field="orderItem.fulfillmentOrderLineItemId" from="lineItem.id"/>
                    <entity-update value-field="orderItem"/>
                </iterate>
            </iterate>
        </actions>
    </service>

    <!-- fulfill order -->
    <service verb="queue" noun="ShopifyFulfillmentSystemMessage" authenticate="anonymous-all">
        <description>Creates a system message for sending to shopify that decribes orders fulfilled in a shipment</description>
        <in-parameters>
            <parameter name="shipmentId" required="true" />
        </in-parameters>
        <out-parameters>
            <parameter name="systemMessageId"/>
        </out-parameters>
        <actions>
            <entity-find-one entity-name="mantle.shipment.Shipment" value-field="shipment" />
            <if condition="!shipment"><return error="true" message="No shipment found with ID ${shipmentId}"/></if>
            <if condition="!shipment.statusId in ['ShipShipped','ShipDelivered']">
                <return error="true" message="ERROR:The shipment ${shipment.shipmentId} must be in status Shipped or Delivered for registering a fulfillment "/>
            </if>

            <set field="tracking_info" from="[:]"/>
            <entity-find entity-name="mantle.shipment.ShipmentPackageRouteSeg" list="packageRouteSegList">
                <econdition field-name="shipmentId"/><order-by field-name="shipmentRouteSegmentSeqId,shipmentPackageSeqId"/></entity-find>
            <if condition="packageRouteSegList &amp;&amp; packageRouteSegList.first().trackingCode">
                <set field="tracking_info.number" from="packageRouteSegList.first().trackingCode"/>
            </if>

            <!-- get the carrierPartyId from the first ShipmentRouteSegment -->
            <entity-find entity-name="mantle.shipment.ShipmentRouteSegment" list="shipmentRouteSegmentList">
                <econdition field-name="shipmentId"/><order-by field-name="shipmentRouteSegmentSeqId"/></entity-find>
            <set field="facilityId" from="shipmentRouteSegmentList.first().originFacilityId"/>
            <set field="carrierPartyId" from="shipmentRouteSegmentList.first().carrierPartyId"/>

            <entity-find-one entity-name="mantle.party.PartyIdentification" value-field="carrierShopifyId">
                <field-map field-name="partyId" from="carrierPartyId"/><field-map field-name="partyIdTypeEnumId" value="PtidShopify"/>
            </entity-find-one>
            <if condition="carrierShopifyId">
                <set field="tracking_info.company" from="carrierShopifyId.idValue"/>
            </if>

            <entity-find entity-name="mantle.shipment.ShipmentItemSource" list="shipmentItemList">
                <econdition field-name="shipmentId"/></entity-find>

            <entity-find-one entity-name="mantle.facility.Facility" value-field="facility" />

            <!-- get all the shopify fulfillment orders from this shipment -->
            <set field="orderIdList" from="shipmentItemList.orderId.unique( false )"/>
            <log message="orderIdList: ${orderIdList}"/>
            <entity-find entity-name="mantle.shopify.ShopifyFulfillmentOrder" list="fulfillmentOrders">
                <econdition field-name="orderId" operator="in" from="orderIdList"/>
                <econdition field-name="locationId" from="facility.externalId"/></entity-find>

            
            <set field="line_items_by_fulfillment_order" from="[]"/>
            <iterate list="fulfillmentOrders" entry="fulfillmentOrder">

                

                <!-- get all the shipped line items from this fulfillment order -->
                <set field="shipmentItemListForOrder" from="shipmentItemList.findAll({it.orderId == fulfillmentOrder.orderId})"/>
                <set field="line_items" from="[]"/>
                <iterate list="shipmentItemListForOrder" entry="shipmentItem">

                    <entity-find-one entity-name="mantle.order.OrderItem" value-field="od">
                        <field-map field-name="orderId" from="shipmentItem.orderId"/>
                        <field-map field-name="orderItemSeqId" from="shipmentItem.orderItemSeqId"/>
                    </entity-find-one>
                    <log message="shipmentItem: ${shipmentItem}"/>

                    <set field="item" from="[:]"/>
                    <set field="item.id" from="od.fulfillmentOrderLineItemId"/>
                    <set field="item.quantity" from="shipmentItem.quantityPicked"/>
                    <set field="line_items" from="line_items.plus(item)"/>
                </iterate>
                <set field="fulfillment_order" from="[:]"/>
                <set field="fulfillment_order.fulfillment_order_id" from="fulfillmentOrder.fulfillmentOrderId"/>
                <set field="fulfillment_order.fulfillment_order_line_items" from="line_items"/>

                <set field="line_items_by_fulfillment_order" from="line_items_by_fulfillment_order.plus(fulfillment_order)"/>
            </iterate>

            <set field="fulfillment" from="[:]"/>
            <set field="fulfillment.message" from="shipment.handlingInstructions"/>
            <set field="fulfillment.notify_customer" from="false"/>
            <set field="fulfillment.tracking_info" from="tracking_info"/>
            <set field="fulfillment.line_items_by_fulfillment_order" from="line_items_by_fulfillment_order"/>

            <entity-find-one entity-name="moqui.service.message.SystemMessageRemote" value-field="remote">
                <field-map field-name="systemMessageTypeId" value="ShopifySystemMessageType"/>
                <field-map field-name="productStoreId" from="shipment.productStoreId"/>
            </entity-find-one>

            <service-call name="org.moqui.impl.SystemMessageServices.queue#SystemMessage" out-map="context"
                in-map="[systemMessageTypeId:'ShopifySystemMessageType', systemMessageRemoteId:remote.systemMessageRemoteId, messageText:groovy.json.JsonOutput.toJson(fulfillment), docType:'fulfillments']"/>
        </actions>
    </service>


    <!-- cancelOrder -->

</services>