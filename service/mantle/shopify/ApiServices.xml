<?xml version="1.0" encoding="UTF-8"?>
<services xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
          xsi:noNamespaceSchemaLocation="http://moqui.org/xsd/service-definition-2.1.xsd">

    <service verb="send" noun="SystemMessageRest">
        <implements service="org.moqui.impl.SystemMessageServices.send#SystemMessage"/>
        <in-parameters>
            <parameter name="systemMessageId" required="true"/>
        </in-parameters>
        <out-parameters>
            <parameter name="response"/>
            <parameter name="systemMessage"/>
        </out-parameters>
        <actions>
            <entity-find-one entity-name="moqui.service.message.SystemMessage" value-field="systemMessage"/>
            <set field="systemMessageType" from="systemMessage.'moqui.service.message.SystemMessageType'"/>

            <if condition="!systemMessage.systemMessageRemoteId">
                <return error="true"
                        message="System message ${systemMessageId} has no systemMessageRemoteId, not sending."/>
            </if>
            <set field="systemMessageRemote" from="systemMessage.'moqui.service.message.SystemMessageRemote'"/>
            <set field="docSubType" from="systemMessage.docSubType?:''"/>
            <set field="response" value=""/>
            <script>import groovy.json.JsonSlurper</script>
            <script><![CDATA[
                def jsonSlurper = new JsonSlurper()
                String urlExpand = ec.resource.expand(systemMessageRemote.sendUrl, "systemMessage", [remoteMessageId:systemMessage.systemMessageId,
                        systemMessageTypeId:systemMessage.systemMessageTypeId, systemMessageRemoteId:systemMessage.systemMessageRemoteId], false)
                logger.info("SENDING MESSAGE TEXT ${systemMessage.messageText}")
                org.moqui.util.RestClient restClient = ec.service.rest()

                if(docSubType.contains("delete")){
                    urlExpand = urlExpand + systemMessage.messageText + ".json"
                    logger.info("URL EXPAND ${urlExpand}")
                    restClient = ec.service.rest().method(org.moqui.util.RestClient.DELETE).uri(urlExpand)
                }else if(docSubType.contains("get")){
                    urlExpand = urlExpand + systemMessage.messageText
                    logger.info("URL EXPAND ${urlExpand}")
                    restClient = ec.service.rest().method(org.moqui.util.RestClient.GET).uri(urlExpand)
                }else{
                    if(systemMessage.docSubControl?.contains('cancelOrder')){
                        urlExpand = urlExpand + systemMessage.docControl + "/cancel.json"
                    }
                    if(systemMessage.docSubControl?.contains('calculateRefund')){
                        urlExpand = urlExpand + systemMessage.docControl + "/refunds/calculate.json"
                    }
                    if(systemMessage.docSubControl?.contains('createFulfillment')){
                        urlExpand = urlExpand + systemMessage.docControl + "/fulfillments.json"

                    }
                    logger.info("URL EXPAND ${urlExpand}")
                    restClient = ec.service.rest().method(org.moqui.util.RestClient.POST).uri(urlExpand)
                            .addHeader("Content-Type", "application/json").jsonObject(systemMessage.messageText)
                }
             
                restClient.basicAuth(systemMessageRemote.username,systemMessageRemote.password)
                org.moqui.util.RestClient.RestResponse restResponse = restClient.call()
                if (restResponse.statusCode < 200 || restResponse.statusCode >= 300) {
                    String errMsg = restResponse.text()
                    ec.message.addError("System message ${systemMessageId} send error response (${restResponse.statusCode}): ${errMsg}")
                    return
                }
                response = jsonSlurper.parseText(restResponse.text())
            ]]></script>

            <!-- TODO: WebFacadeImpl.handleSystemMessage() will need to return a message ID before we can do this: <set field="remoteMessageId" from=""/> -->
        </actions>
    </service>

    <service verb="get" noun="ProductData">
        <in-parameters>
            <parameter name="productId" required="true"/>
        </in-parameters>
        <out-parameters>
            <parameter name="productData"/>
        </out-parameters>
        <actions>
            <script>import groovy.json.JsonSlurper</script>
            <entity-find-one entity-name="mantle.product.Product" value-field="product">
                <field-map field-name="productId"/>
            </entity-find-one>
            <entity-find-one entity-name="mantle.product.ProductContent" value-field="productContent">
                <field-map field-name="productId"/>
                <field-map field-name="productContentTypeEnumId" value="PcntImageDetail"/>
            </entity-find-one>
            <set field="images" from="[]"/>
            <set field="prodVariants" from="[]"/>
            <set field="prodOptions" from="[]"/>
            <set field="prodOptionsMap" from="new HashMap()"/>
            <log message="DOMAIN ${storeDomain}"/>
            <!-- HOW TO GET THIS ROUTE WITHOUT BURNED IT ${storeDomain} -->
            <if condition="productContent">
                <set field="image" from="[src: 'https://www.rcherbals.com/store/content/productImage/' + productContent.productContentId]"/>
                <script>images.add(image)</script>
            </if>
            <if condition="product.productTypeEnumId == 'PtVirtual'">
                <then>
                    <!-- Get all the products associated to the parent product /-->
                    <entity-find entity-name="mantle.product.ProductAssoc" list="assocList">
                        <econdition field-name="productId"/>
                        <econdition field-name="fromDate" operator="is-not-null"/>
                        <econdition field-name="thruDate" operator="is-null"/>
                    </entity-find>
                    <iterate list="assocList" entry="assoc">
                        <!-- Each product associated has at least one feature so we get all possible features /-->
                        <entity-find entity-name="mantle.product.feature.ProductAndFeatureAndFeatureAppl" list="featureList">
                            <econdition field-name="productId" from="assoc.toProductId"/>
                            <econdition field-name="fromDate" operator="is-not-null"/>
                            <econdition field-name="thruDate" operator="is-null"/>
                            <order-by field-name="productFeatureDescription"/>
                        </entity-find>

                        <service-call name="mantle.product.PriceServices.get#ProductPrice" out-map="priceSet" in-map="[productId:assoc.toProductId]"/>

                        <entity-find-one entity-name="mantle.product.ProductIdentification" value-field="prodUPC">
                            <field-map field-name="productId" from="assoc.toProductId"/>
                            <field-map field-name="productIdTypeEnumId" value="PidtUpca"/>
                        </entity-find-one>

                        <script><![CDATA[
                            /**
                                The featureList is the list of all the features that an assoc has,
                                if it's only one feature, we don't need to make the combinations
                                if it the product has more than one feature we have to make the combinations
                                in order to follow the shopify format.

                                NOTE: Shopify supports products that has at most 3 features.
                            **/
                            if(featureList.size() == 1){
                                prodVariants.add(new HashMap([name:featureList[0].productFeatureDescription, option1:featureList[0].productFeatureDescription, price:priceSet.price, inventory_management:'shopify', barcode: prodUPC.idValue]))
                            }else if(featureList.size() == 2){
                                prodVariants.add(new HashMap([name:featureList[0].productFeatureDescription + "/" + featureList[1].productFeatureDescription, option1:featureList[0].productFeatureDescription, option2:featureList[1].productFeatureDescription, price:priceSet.price, inventory_management:'shopify', barcode: prodUPC.idValue]))
                            }else if(featureList.size() == 3){
                                prodVariants.add(new HashMap([name:featureList[0].productFeatureDescription + "/" + featureList[1].productFeatureDescription + "/" + featureList[2].productFeatureDescription, option1:featureList[0].productFeatureDescription, option2:featureList[1].productFeatureDescription, option3:featureList[2].productFeatureDescription, price:priceSet.price, inventory_management:'shopify', barcode: prodUPC.idValue]))
                            }
                        ]]>
                        </script>
                        <iterate list="featureList" entry="feature">
                            <set field="item" from="feature.productFeatureTypeEnumId"/>
                            <script><![CDATA[
                                def optionSet = prodOptionsMap.get(item)
                                if (!optionSet) {
                                    prodOptionsMap.put(item, [feature.productFeatureDescription])
                                } else {
                                    if(!optionSet.contains(feature.productFeatureDescription)){
                                       optionSet.add(feature.productFeatureDescription)
                                    }
                                }
                            ]]></script>
                        </iterate>
                        <!-- MAKE THE COMBINATIONS FOR THE PRODUCT WITH THE FEATURELIST  /-->
                    </iterate>
                    <script><![CDATA[
                        String[] keyList = prodOptionsMap.keySet()
                        if(keyList.length == 1){
                            def options1 = prodOptionsMap.get(keyList[0])
                            prodOptions.add(new HashMap([name:keyList[0], values:options1]))
                        }else if(keyList.length == 2){
                            def options1 = prodOptionsMap.get(keyList[0])
                            def options2 = prodOptionsMap.get(keyList[1])
                            prodOptions.add(new HashMap([name:keyList[0], values:options1]))
                            prodOptions.add(new HashMap([name:keyList[1], values:options2]))
                        }else if(keyList.length == 3){
                            def options1 = prodOptionsMap.get(keyList[0])
                            def options2 = prodOptionsMap.get(keyList[1])
                            def options3 = prodOptionsMap.get(keyList[2])
                            prodOptions.add(new HashMap([name:keyList[0], values:options1]))
                            prodOptions.add(new HashMap([name:keyList[1], values:options2]))
                            prodOptions.add(new HashMap([name:keyList[2], values:options3]))
                        }
                    ]]></script>
                    <log message="OPTIONS ${prodOptions}"/>
                </then>
            </if>
            <set field="productData" from="[title: product.productName,
                                        body_html: '',
                                        vendor: '',
                                        images: images,
                                        variants: prodVariants,
                                        options: prodOptions]"/>
        </actions>
    </service>

    <service verb="queue" noun="ProductSystemMessage">
        <in-parameters>
            <parameter name="productId" required="true"/>
        </in-parameters>
        <actions>
            <service-call name="mantle.shopify.ApiServices.get#ProductData" 
                          in-map="[productId: productId, productStoreId: productStoreId]"
                          out-map="context" />

            <set field="json" from="groovy.json.JsonOutput.toJson([product: productData])"/>

            <!-- After the JSON is created correctly we create a SystemMessage with the shopify API data and the product JSON as messageText/-->
            <service-call name="org.moqui.impl.SystemMessageServices.queue#SystemMessage" out-map="context"
                    in-map="[systemMessageTypeId:'ShopifyProductMessage', systemMessageRemoteId:'DEMO_SHOPIFY_PRODUCTS_REMOTE',
                        messageText:json, productId:productId]"/>
        </actions>
    </service>

    <service verb="send" noun="ProductSystemMessage">
        <implements service="org.moqui.impl.SystemMessageServices.send#SystemMessage"/>
        <in-parameters>
            <parameter name="systemMessageId" required="true"/>
        </in-parameters>
        <actions>
            <service-call name="mantle.shopify.ApiServices.send#SystemMessageRest" 
                          in-map="[systemMessageId: systemMessageId]"
                          out-map="context" />
            <if condition="response.product.variants.size &gt; 0">
                <set field="shopifyVariants" from="response.product.variants"/>
                <log message="VARIANTS ${shopifyVariants}"/>
                <iterate list="shopifyVariants" entry="shopifyVariant">
                    <entity-find entity-name="mantle.product.ProductIdentification" list="prodUPCs">
                        <econdition field-name="idValue" from="shopifyVariant.barcode"/>
                    </entity-find>
                    <set field="productId" from="prodUPCs.first().productId"/>
                    <service-call name="create#mantle.product.ProductIdentification" out-map="context" in-map="[productId:productId, productIdTypeEnumId:'PidtVariantShopify', idValue: shopifyVariant.id]"/>
                    <service-call name="create#mantle.product.ProductIdentification" out-map="context" in-map="[productId:productId, productIdTypeEnumId:'PidtInventoryItemShopify', idValue: shopifyVariant.inventory_item_id]"/>
                </iterate>
            </if>
            <service-call name="create#mantle.product.ProductIdentification" out-map="context" in-map="[productId:systemMessage.productId, productIdTypeEnumId:'PidtShopify', idValue: response.product.id]"/>
        </actions>
    </service>

    <service verb="get" noun="ProductCategoryData">
        <in-parameters>
            <parameter name="productCategoryId" required="true"/>
        </in-parameters>
        <out-parameters>
            <parameter name="productCategoryData"/>
        </out-parameters>
        <actions>
            <entity-find-one entity-name="mantle.product.category.ProductCategory" value-field="productCategory">
                <field-map field-name="productCategoryId"/>
            </entity-find-one>
            <entity-find entity-name="mantle.product.category.ProductCategoryMember" list="productCategoryMembers">
                <econdition field-name="productCategoryId"/>
                <econdition field-name="thruDate" from="null"/>
            </entity-find>
            <script>import groovy.json.JsonSlurper</script>
            <set field="shopifyCollectItems" from="[]"/>
            <iterate list="productCategoryMembers" entry="productCategoryMember">
                <entity-find-one entity-name="mantle.product.ProductIdentification" value-field="productIdentification">
                    <field-map field-name="productId" from="productCategoryMember.productId"/>
                    <field-map field-name="productIdTypeEnumId" value="PidtShopify"/>
                </entity-find-one>
                <if condition="productIdentification">
                    <entity-find-one entity-name="mantle.product.Product" value-field="product">
                        <field-map field-name="productId" from="productCategoryMember.productId"/>
                    </entity-find-one>
                    <script>
                        <![CDATA[
                            shopifyCollectItems.add(new HashMap([product_id:productIdentification.idValue]))
                        ]]>
                    </script>
                </if>
            </iterate>
            <if condition="shopifyCollectItems.size &gt; 0"><then>
                <set field="productCategoryData" from="[title: productCategory.categoryName, collects: shopifyCollectItems]"/>
            </then><else>
                <set field="productCategoryData" from="[title: productCategory.categoryName]"/>
            </else></if>
        </actions>
    </service>

    <service verb="queue" noun="CreateCollectionSystemMessage">
        <in-parameters>
            <parameter name="productCategoryId" required="true"/>
        </in-parameters>
        <actions>
            <service-call name="mantle.shopify.ApiServices.get#ProductCategoryData"
                          in-map="[productCategoryId: productCategoryId, productStoreId: productStoreId]"
                          out-map="context" />

            <set field="json" from="groovy.json.JsonOutput.toJson([custom_collection: productCategoryData])"/>

            <!-- After the JSON is created correctly we create a SystemMessage with the shopify API data and the collection JSON as messageText/-->
            <service-call name="org.moqui.impl.SystemMessageServices.queue#SystemMessage" out-map="context"
                          in-map="[systemMessageTypeId:'ShopifyCreateCollectionMessage', systemMessageRemoteId:'DEMO_SHOPIFY_CREATE_COLLECTION_REMOTE',
                        messageText:json, productCategoryId:productCategoryId]"/>
        </actions>
    </service>

    <service verb="send" noun="CreateCollectionSystemMessage">
        <implements service="org.moqui.impl.SystemMessageServices.send#SystemMessage"/>
        <in-parameters>
            <parameter name="systemMessageId" required="true"/>
        </in-parameters>
        <actions>
            <service-call name="mantle.shopify.ApiServices.send#SystemMessageRest"
                          in-map="[systemMessageId: systemMessageId]"
                          out-map="context" />

            <service-call name="update#mantle.product.category.ProductCategory" out-map="context" in-map="[productCategoryId:systemMessage.productCategoryId, pseudoId:response.custom_collection.id]"/>

            <service-call name="mantle.shopify.ApiServices.queue#GetCollectsSystemMessage" out-map="context"
                          in-map="[productCategoryId:systemMessage.productCategoryId]"/>
        </actions>
    </service>

    <service verb="get" noun="ShopifyCollectionData">
        <in-parameters>
            <parameter name="productCategoryId" required="true"/>
        </in-parameters>
        <out-parameters>
            <parameter name="shopifyCollectionId"/>
        </out-parameters>
        <actions>
            <entity-find-one entity-name="mantle.product.category.ProductCategory" value-field="productCategory">
                <field-map field-name="productCategoryId"/>
            </entity-find-one>
            <set field="shopifyCollectionId" from="productCategory.pseudoId"/>
        </actions>
    </service>

    <service verb="queue" noun="DeleteCollectionSystemMessage">
        <in-parameters>
            <parameter name="productCategoryId" required="true"/>
        </in-parameters>
        <actions>
            <service-call name="mantle.shopify.ApiServices.get#ShopifyCollectionData"
                          in-map="[productCategoryId: productCategoryId]"
                          out-map="context" />

            <set field="idParam" from="shopifyCollectionId"/>

            <!-- After the JSON is created correctly we create a SystemMessage with the shopify API data and the collection Id as messageText/-->
            <service-call name="org.moqui.impl.SystemMessageServices.queue#SystemMessage" out-map="context"
                          in-map="[systemMessageTypeId:'ShopifyDeleteCollectionMessage', systemMessageRemoteId:'DEMO_SHOPIFY_DELETE_COLLECTION_REMOTE',
                            messageText:idParam, productCategoryId:productCategoryId, docSubType: 'deleteCollection']"/>
        </actions>
    </service>

    <service verb="send" noun="DeleteCollectionSystemMessage">
        <implements service="org.moqui.impl.SystemMessageServices.send#SystemMessage"/>
        <in-parameters>
            <parameter name="systemMessageId" required="true"/>
        </in-parameters>
        <actions>
            <service-call name="mantle.shopify.ApiServices.send#SystemMessageRest"
                          in-map="[systemMessageId: systemMessageId]"
                          out-map="context" />

            <service-call name="update#mantle.product.category.ProductCategory" out-map="context" in-map="[productCategoryId:systemMessage.productCategoryId, pseudoId:'']"/>

            <entity-find entity-name="mantle.product.category.ProductCategoryMember" list="productCategoryMembers">
                <econdition field-name="productCategoryId"/>
                <econdition field-name="thruDate" from="null"/>
            </entity-find>

            <iterate list="productCategoryMembers" entry="productCategoryMember">
                <service-call name="update#mantle.product.category.ProductCategoryMember" out-map="context" in-map="productCategoryMember + [pseudoId:'']"/>
            </iterate>
        </actions>
    </service>

    <service verb="get" noun="ProductCategoryMemberData">
        <in-parameters>
            <parameter name="productCategoryId" required="true"/>
            <parameter name="productId" required="true"/>
        </in-parameters>
        <out-parameters>
            <parameter name="collectData"/>
        </out-parameters>
        <actions>
            <entity-find-one entity-name="mantle.product.category.ProductCategory" value-field="productCategory">
                <field-map field-name="productCategoryId" from="productCategoryId"/>
            </entity-find-one>

            <entity-find-one entity-name="mantle.product.ProductIdentification" value-field="productIdentification">
                <field-map field-name="productId" from="productId"/>
                <field-map field-name="productIdTypeEnumId" value="PidtShopify"/>
            </entity-find-one>
            <set field="collectData" value="."/>
            <if condition="productIdentification">
                <script>
                    <![CDATA[
                        collectData = [product_id:productIdentification.idValue, collection_id:productCategory.pseudoId]
                    ]]>
                </script>
            </if>
        </actions>
    </service>

    <service verb="queue" noun="CreateCollectSystemMessage">
        <in-parameters>
            <parameter name="productCategoryId" required="true"/>
            <parameter name="productId" required="true"/>
        </in-parameters>
        <actions>
            <service-call name="mantle.shopify.ApiServices.get#ProductCategoryMemberData"
                          in-map="[productCategoryId: productCategoryId, productId: productId]"
                          out-map="context" />

            <set field="json" from="groovy.json.JsonOutput.toJson([collect: collectData])"/>
            <!-- After the JSON is created correctly we create a SystemMessage with the shopify API data and the collect JSON as messageText/-->
            <service-call name="org.moqui.impl.SystemMessageServices.queue#SystemMessage" out-map="context"
                          in-map="[systemMessageTypeId:'ShopifyCreateCollectMessage', systemMessageRemoteId:'DEMO_SHOPIFY_CREATE_COLLECT_REMOTE',
                        messageText:json, productCategoryId:productCategoryId, productId:productId]"/>
        </actions>
    </service>

    <service verb="send" noun="CreateCollectSystemMessage">
        <implements service="org.moqui.impl.SystemMessageServices.send#SystemMessage"/>
        <in-parameters>
            <parameter name="systemMessageId" required="true"/>
        </in-parameters>
        <actions>
            <service-call name="mantle.shopify.ApiServices.send#SystemMessageRest"
                          in-map="[systemMessageId: systemMessageId]"
                          out-map="context" />

            <entity-find entity-name="mantle.product.category.ProductCategoryMember" list="productCategoryMembers">
                <econdition field-name="productCategoryId" from="systemMessage.productCategoryId"/>
                <econdition field-name="productId" from="systemMessage.productId"/>
                <econdition field-name="thruDate" from="null"/>
            </entity-find>
            <set field="productCategoryMember" from="productCategoryMembers.first()"/>
            <service-call name="update#mantle.product.category.ProductCategoryMember" out-map="context" in-map="[productId:productCategoryMember.productId, productCategoryId:productCategoryMember.productCategoryId, fromDate:productCategoryMember.fromDate, shopifyId:response.collect.id]"/>
        </actions>
    </service>

    <service verb="queue" noun="GetCollectsSystemMessage">
        <in-parameters>
            <parameter name="productCategoryId" required="true"/>
        </in-parameters>
        <actions>
            <entity-find-one entity-name="mantle.product.category.ProductCategory" value-field="productCategory">
                <field-map field-name="productCategoryId" from="productCategoryId"/>
            </entity-find-one>
            <set field="shopifyGetCollectsParam" from="'?collection_id='+productCategory.pseudoId"/>
            <!-- After the JSON is created correctly we create a SystemMessage with the shopify API data and the collect params as messageText/-->
            <log message="MESSAGE PARAMS ${shopifyGetCollectsParam}"/>
            <service-call name="org.moqui.impl.SystemMessageServices.queue#SystemMessage" out-map="context"
                          in-map="[systemMessageTypeId:'ShopifyGetCollectsMessage', systemMessageRemoteId:'DEMO_SHOPIFY_GET_COLLECTS_REMOTE',
                            messageText:shopifyGetCollectsParam, productCategoryId:productCategoryId, productId:productId, docSubType: 'getCollects']"/>
        </actions>
    </service>

    <service verb="send" noun="GetCollectsSystemMessage">
        <implements service="org.moqui.impl.SystemMessageServices.send#SystemMessage"/>
        <in-parameters>
            <parameter name="systemMessageId" required="true"/>
        </in-parameters>
        <actions>
            <service-call name="mantle.shopify.ApiServices.send#SystemMessageRest"
                          in-map="[systemMessageId: systemMessageId]"
                          out-map="context"/>

            <entity-find entity-name="mantle.product.category.ProductCategoryMember" list="productCategoryMembers">
                <econdition field-name="productCategoryId" from="systemMessage.productCategoryId"/>
                <econdition field-name="thruDate" from="null"/>
            </entity-find>

            <set field="productCategoryMember" from="productCategoryMembers.first()"/>

            <iterate list="productCategoryMembers" entry="productCategoryMember">
                <entity-find-one entity-name="mantle.product.ProductIdentification" value-field="productIdentification">
                    <field-map field-name="productId" from="productCategoryMember.productId"/>
                    <field-map field-name="productIdTypeEnumId" value="PidtShopify"/>
                </entity-find-one>
                <set field="collect" from="response.collects.find{it.product_id.toString().equals(productIdentification.idValue.toString())}"/>
                <if condition="collect">
                    <service-call name="update#mantle.product.category.ProductCategoryMember" out-map="context" in-map="[productId:productCategoryMember.productId, productCategoryId:productCategoryMember.productCategoryId, fromDate:productCategoryMember.fromDate, shopifyId:collect.id]"/>
                </if>
            </iterate>
        </actions>
    </service>

    <service verb="queue" noun="DeleteCollectSystemMessage">
        <in-parameters>
            <parameter name="productCategoryId" required="true"/>
            <parameter name="productId" required="true"/>
        </in-parameters>
        <actions>
            <entity-find-one entity-name="mantle.product.category.ProductCategoryMember" value-field="productCategoryMember">
                <field-map field-name="productCategoryId" from="productCategoryId"/>
                <field-map field-name="productId" from="productId"/>
                <field-map field-name="thruDate" from="null"/>
            </entity-find-one>

            <set field="idParam" from="productCategoryMember.shopifyId"/>
            <!-- After the JSON is created correctly we create a SystemMessage with the shopify API data and the collect Id as messageText/-->
            <service-call name="org.moqui.impl.SystemMessageServices.queue#SystemMessage" out-map="context"
                          in-map="[systemMessageTypeId:'ShopifyDeleteCollectMessage', systemMessageRemoteId:'DEMO_SHOPIFY_DELETE_COLLECT_REMOTE',
                            messageText:idParam, productCategoryId:productCategoryId, productId:productId, docSubType: 'deleteCollect']"/>
        </actions>
    </service>

    <service verb="send" noun="DeleteCollectSystemMessage">
        <implements service="org.moqui.impl.SystemMessageServices.send#SystemMessage"/>
        <in-parameters>
            <parameter name="systemMessageId" required="true"/>
        </in-parameters>
        <actions>
            <service-call name="mantle.shopify.ApiServices.send#SystemMessageRest"
                          in-map="[systemMessageId: systemMessageId]"
                          out-map="context"/>

            <entity-find-one entity-name="mantle.product.category.ProductCategoryMember" value-field="productCategoryMember">
                <field-map field-name="productCategoryId" from="systemMessage.productCategoryId"/>
                <field-map field-name="productId" from="systemMessage.productId"/>
                <field-map field-name="thruDate" from="null"/>
            </entity-find-one>
            <service-call name="update#mantle.product.category.ProductCategoryMember" out-map="context" in-map="[productId:productCategoryMember.productId, productCategoryId:productCategoryMember.productCategoryId, fromDate:productCategoryMember.fromDate, shopifyId:'']"/>
        </actions>
    </service>

    <service verb="queue" noun="GetOrdersSystemMessage">
        <actions>
            <service-call name="org.moqui.impl.SystemMessageServices.queue#SystemMessage" out-map="context"
                          in-map="[systemMessageTypeId:'ShopifyGetOrdersMessage', systemMessageRemoteId:'DEMO_SHOPIFY_GET_ORDERS_REMOTE', messageText: 'paid', docSubType: 'getOrders']"/>
        </actions>
    </service>

    <service verb="send" noun="GetOrdersSystemMessage">
        <implements service="org.moqui.impl.SystemMessageServices.send#SystemMessage"/>
        <in-parameters>
            <parameter name="systemMessageId" required="true"/>
        </in-parameters>
        <actions>
            <service-call name="mantle.shopify.ApiServices.send#SystemMessageRest"
                          in-map="[systemMessageId: systemMessageId]"
                          out-map="context"/>
            <entity-find-one entity-name="moqui.service.message.SystemMessageRemote" value-field="systemMessageRemote">
                <field-map field-name="systemMessageRemoteId" from="systemMessage.systemMessageRemoteId"/>
            </entity-find-one>
            <entity-find-one entity-name="mantle.product.store.ProductStore" value-field="productStore">
                <field-map field-name="productStoreId" from="systemMessageRemote.productStoreId"/>
            </entity-find-one>
            <iterate list="response.orders" entry="order">
                <set field="customer" from="order.customer"/>
                <set field="shippingAddress" from="order.shipping_address"/>
                <set field="billingAddress" from="order.billing_address"/>
                <set field="paymentDetails" from="order.payment_details"/>
                <set field="orderItems" from="order.line_items"/>
                <if condition="!customer">
                    <return error="ERROR: ORDER WITHOUT CUSTOMER FOUND"/>
                </if>
                <if condition="!shippingAddress">
                    <return error="ERROR: ORDER WITHOUT SHIPPING ADDRESS"/>
                </if>
                <if condition="!billingAddress">
                    <log message="ORDER WITHOUT BILLING ADDRESS, SHIPPING ADDRESS WILL BE ASSIGNED INSTEAD"/>
                    <set field="billingAddress" from="shippingAddress"/>
                </if>
                <if condition="!paymentDetails">
                    <return error="ERROR: ORDER WITHOUT PAYMENT DETAILS"/>
                </if>
                <if condition="!orderItems">
                    <return error="ERROR: ORDER WITHOUT ORDER ITEMS"/>
                </if>
                <service-call name="popstore.CustomerServices.find#PartyByEmail" in-map="[emailAddress:customer.email]" out-map="context"/>
                <entity-find entity-name="mantle.order.OrderHeader" list="createdOrder">
                    <econdition field-name="externalId" from="order.id"/>
                </entity-find>
                <if condition="createdOrder"><then>
                    <log message="SHOPIFY ORDER #${order.order_number} ALREADY CREATED, ORDER ID: ${createdOrder.first().orderId}"/>
                </then>
                    <else>
                        <if condition="partyIds.size() &gt; 0"><then>
                            <set field="partyId" from="partyIds.first()"/>
                        </then><else>
                            <service-call name="mantle.party.PartyServices.create#Account" in-map="[firstName:customer.first_name,
                                                                                                      lastName:customer.last_name,
                                                                                                      username: customer.email,
                                                                                                      newPassword: 'shopify_123*',
                                                                                                      newPasswordVerify: 'shopify_123*',
                                                                                                      emailAddress:customer.email,
                                                                                                      loginAfterCreate:false]" out-map="context"/>
                        </else></if>
                        <entity-find entity-name="mantle.party.contact.PartyContactMechPostalAddress" list="postalMechList">
                            <econdition field-name="partyId" from="partyId"/>
                            <econdition field-name="contactMechPurposeId" value="PostalPrimary"/>
                        </entity-find>
                        <entity-find entity-name="mantle.party.contact.PartyContactMechTelecomNumber" list="telecomMechList">
                            <econdition field-name="partyId" from="partyId"/>
                            <econdition field-name="contactMechPurposeId" value="PhonePrimary"/>
                        </entity-find>
                        <if condition="postalMechList.size() &gt; 0"><then>
                            <set field="postalMech" from="postalMechList.first()"/>
                            <if condition="postalMech.address1.equals(shippingAddress.address1) || postalMech.address2.equals(shippingAddress.address2)">
                                <set field="postalContactMechId" from="postalMech.contactMechId"/>
                                <log message="SHIPPING ADDRESS ALREADY EXISTS"/>
                            </if>
                        </then><else>
                            <entity-find entity-name="moqui.basic.Geo" list="shippingCountryList">
                                <econdition field-name="geoTypeEnumId" value="GEOT_COUNTRY"/>
                                <econdition field-name="geoCodeAlpha2" from="shippingAddress.country_code"/>
                            </entity-find>
                            <entity-find entity-name="moqui.basic.Geo" list="shippingStateList">
                                <econdition field-name="geoId" from="shippingCountryList.first().geoId + '_' + shippingAddress.province_code"/>
                                <econdition field-name="geoTypeEnumId" value="GEOT_STATE"/>
                                <econdition field-name="geoCodeAlpha2" from="shippingAddress.province_code"/>
                            </entity-find>
                            <entity-find entity-name="moqui.basic.Geo" list="billingCountryList">
                                <econdition field-name="geoTypeEnumId" value="GEOT_COUNTRY"/>
                                <econdition field-name="geoCodeAlpha2" from="billingAddress.country_code"/>
                            </entity-find>
                            <entity-find entity-name="moqui.basic.Geo" list="billingStateList">
                                <econdition field-name="geoId" from="billingCountryList.first().geoId + '_' + billingAddresss.province_code"/>
                                <econdition field-name="geoTypeEnumId" value="GEOT_STATE"/>
                                <econdition field-name="geoCodeAlpha2" from="billingAddress.province_code"/>
                            </entity-find>
                            <service-call name="mantle.party.ContactServices.store#PartyContactInfo" in-map="[partyId: partyId,
                                                                                                          address1:shippingAddress.address1,
                                                                                                          address2:shippingAddress.address2,
                                                                                                          postalContactMechPurposeId: 'PostalPrimary',
                                                                                                          toName: shippingAddress.name,
                                                                                                          postalCode:shippingAddress.zip,
                                                                                                          countryGeoId: shippingCountryList.first().geoId,
                                                                                                          stateProvinceGeoId: shippingStateList.first().geoId,
                                                                                                          city: shippingAddress.city,
                                                                                                          emailAddress: customer.email]" out-map="shippingMechData"/>
                            <set field="postalContactMechId" from="shippingMechData.postalContactMechId"/>
                            <service-call name="mantle.party.ContactServices.store#PartyContactInfo" in-map="[partyId: partyId,
                                                                                                          address1:billingAddress.address1,
                                                                                                          address2:billingAddress.address2,
                                                                                                          postalContactMechPurposeId: 'PostalBilling',
                                                                                                          toName: billingAddress.name,
                                                                                                          postalCode:billingAddress.zip,
                                                                                                          countryGeoId: billingCountryList.first().geoId,
                                                                                                          stateProvinceGeoId: billingStateList.first().geoId,
                                                                                                          city: billingAddress.city,
                                                                                                          emailAddress: customer.email]" out-map="billingMechData"/>


                        </else></if>
                        <set field="contactNumber" from="shippingAddress.phone.replaceAll('-','')"/>
                        <set field="contactNumber" from="contactNumber.replaceAll('\\+','')"/>
                        <set field="phoneCountryCode" from="contactNumber.substring(0,3)"/>
                        <set field="phoneNumber" from="contactNumber.substring(3).replaceAll(' ','')"/>
                        <if condition="telecomMechList.size() &gt; 0"><then>
                            <set field="telecomMech" from="telecomMechList.first()"/>
                            <if condition="telecomMech.contactNumber.equals(shippingAddress.phone)">
                                <set field="telecomContactMechId" from="telecomMech.contactMechId"/>
                                <log message="TELECOM NUMBER ALREADY EXISTS"/>
                            </if>
                        </then><else>
                            <service-call name="mantle.party.ContactServices.store#PartyContactInfo" in-map="[partyId: partyId,
                                                                                                          contactNumber: phoneNumber,
                                                                                                          countryCode: phoneCountryCode,
                                                                                                          telecomContactMechPurposeId:'PhonePrimary']" out-map="telecomMechData"/>
                            <set field="telecomContactMechId" from="telecomMechData.telecomContactMechId"/>
                        </else></if>
                        <!-- Create order based on shopify data -->
                        <service-call name="mantle.order.OrderServices.create#Order" in-map="[productStoreId: productStore.productStoreId,
                                                                                      displayId: order.order_number,
                                                                                      externalId: order.id,
                                                                                      orderName: 'Shopify Order-' + order.order_number,
                                                                                      systemMessageRemoteId: systemMessageRemote.systemMessageRemoteId,
                                                                                      customerPartyId: partyId]" out-map="context"/>
                        <entity-find-one entity-name="mantle.order.OrderHeader" value-field="orderHeader"/>
                        <entity-find-one entity-name="mantle.order.OrderPart" value-field="orderPart"/>
                        <!-- Adding product to created order -->
                        <iterate list="orderItems" entry="orderItem">
                            <entity-find entity-name="mantle.product.ProductIdentification" list="productIdList">
                                <econdition field-name="idValue" from="orderItem.variant_id"/>
                                <econdition field-name="productIdTypeEnumId" value="PidtVariantShopify"/>
                            </entity-find>
                            <if condition="orderHeader &amp;&amp; orderPart &amp;&amp; productIdList">
                                <set field="productId" from="productIdList.first().productId"/>
                                <service-call name="mantle.order.OrderServices.add#OrderProductQuantity" in-map="[orderId: orderHeader.orderId,
                                                                                                productId: productId,
                                                                                                orderItemSeqId: 01,
                                                                                                unitAmount: orderItem.price,
                                                                                                itemTypeEnumId: 'ItemProduct',
                                                                                                productStoreId: productStore.productStoreId,
                                                                                                quantity: orderItem.quantity,
                                                                                                unitAmount:orderItem.price]" out-map="context"/>
                                <entity-find entity-name="mantle.order.OrderItem" list="orderItemList">
                                    <econdition field-name="orderId" from="orderHeader.orderId"/>
                                    <econdition field-name="productId" from="productId"/>
                                </entity-find>
                                <if condition="orderItemList">
                                    <service-call name="update#mantle.order.OrderItem" out-map="context" in-map="orderItemList.first() + [externalItemSeqId:orderItem.id]"/>
                                </if>
                            </if>
                        </iterate>
                        <!-- DISCOUNTS -->
                        <if condition="orderHeader &amp;&amp; orderPart">
                            <!-- PAYMENT METHOD -->
                            <service-call name="create#mantle.account.method.PaymentMethod" out-map="context" in-map="[ownerPartyId: partyId,
                                                                                                               paymentMethodTypeEnumId:'PmtCreditCard',
                                                                                                               firstNameOnAccount: customer.first_name,
                                                                                                               lastNameOnAccount:customer.last_name,
                                                                                                               description: paymentDetails.credit_card_company + ' ' + paymentDetails.credit_card_number ]"/>
                            <set field="fromPartyId" from="orderPart.customerPartyId"/>
                            <entity-find entity-name="mantle.order.OrderPartParty" list="billToList">
                                <econdition field-name="orderId"/><econdition field-name="orderPartSeqId"/>
                                <econdition field-name="roleTypeId" value="CustomerBillTo"/>
                            </entity-find>
                            <if condition="billToList"><set field="fromPartyId" from="billToList[0].partyId"/></if>
                            <service-call name="mantle.account.PaymentServices.create#Payment" out-map="context"
                                          in-map="context + [amount:(amount ?: orderPart.partTotal), amountUomId:orderHeader.currencyUomId,
                                  statusId:'PmntDelivered', effectiveDate:ec.user.nowTimestamp, fromPartyId:fromPartyId, toPartyId:orderPart.vendorPartyId]"/>
                            <service-call name="mantle.order.OrderServices.set#OrderBillingShippingInfo" in-map="[orderId: orderHeader.orderId,
                                                                                                          paymentId: paymentId,
                                                                                                          paymentMethodId: paymentMethodId,
                                                                                                          shippingPostalContactMechId: postalContactMechId,
                                                                                                          shippingTelecomContactMechId: telecomContactMechId]" out-map="updatedPayment"/>
                            <service-call name="mantle.other.TaxServices.calculate#OrderSalesTax" in-map="[orderId:orderId, destinationAddressContactMechId:postalContactMechId]"/>
                            <service-call name="mantle.order.OrderServices.update#OrderStatus" out-map="context" in-map="[orderId: orderHeader.orderId,
                                                                                                                  placedDate: ec.user.nowTimestamp,
                                                                                                                  statusId: 'OrderPlaced']"/>
                            <service-call name="mantle.order.OrderServices.update#OrderStatus" out-map="context" in-map="[orderId: orderHeader.orderId,
                                                                                                                  approvedDate: ec.user.nowTimestamp,
                                                                                                                  statusId: 'OrderApproved']"/>
                        </if>
                    </else></if>
            </iterate>
        </actions>
    </service>

    <service verb="queue" noun="SetInventorySystemMessage">
        <description>Service to update the quantity available in stock for a product</description>
        <in-parameters>
            <parameter name="productId" required="true"/>
        </in-parameters>
        <actions>

            <entity-find-one entity-name="mantle.product.ProductIdentification" value-field="shopifyInvenotoryItem">
                <field-map field-name="productId" from="productId"/>
                <field-map field-name="productIdTypeEnumId" value="PidtInventoryItemShopify"/>
            </entity-find-one>

            <if condition="!shopifyInvenotoryItem">
                <return error="true"
                        message="The productId ${productId} does not exist"/>
            </if>

            <set field="inventoryItemId" from="shopifyInvenotoryItem.idValue"/>

            <!-- get the store id -->
            <service-call name="mantle.shopify.ShopifyServices.get#LocationId" out-map="context"   in-map="[ remoteId:'DEMO_SHOPIFY_SET_INVENTORY_REMOTE']"/>

            <!-- we need to find the available quantity for the current product -->
            <entity-find entity-name="mantle.product.asset.Asset" list="assetList">
                <econdition field-name="productId"/>
                <econdition field-name="quantityOnHandTotal" operator="greater" value="0"/>
                <econdition field-name="availableToPromiseTotal" operator="greater" value="0"/>
                <econdition field-name="assetTypeEnumId" value="AstTpInventory"/>
            </entity-find>

            <set field="avilableToPromiseList" from="assetList*.availableToPromiseTotal"/>
            <set field="available" from="avilableToPromiseList.findAll{it != null}.sum()?:0"/>

            <set field="json" from="groovy.json.JsonOutput.toJson([
                location_id:locationId,
                inventory_item_id:inventoryItemId,
                available:available
                ])"/>

            <!--the api is called for update the available quantity-->
            <service-call name="org.moqui.impl.SystemMessageServices.queue#SystemMessage" out-map="context"
                    in-map="[systemMessageTypeId:'ShopifySetInventoryMessage', systemMessageRemoteId:'DEMO_SHOPIFY_SET_INVENTORY_REMOTE',
                        messageText:json,docSubType: 'upDateInventoryLevel']"/>
        </actions>
    </service>

    <service verb="send" noun="SetInventorySystemMessage">
        <implements service="org.moqui.impl.SystemMessageServices.send#SystemMessage"/>
        <in-parameters>
            <parameter name="systemMessageId" required="true"/>
        </in-parameters>
        <actions>
            <service-call name="mantle.shopify.ApiServices.send#SystemMessageRest"
                          in-map="[systemMessageId: systemMessageId]"
                          out-map="context" />
        </actions>
    </service>

    <service verb="send" noun="CancelOrderSystemMessage">
        <implements service="org.moqui.impl.SystemMessageServices.send#SystemMessage"/>
        <in-parameters>
            <parameter name="systemMessageId" required="true"/>
        </in-parameters>
        <actions>
            <service-call name="mantle.shopify.ApiServices.send#SystemMessageRest" 
                          in-map="[systemMessageId: systemMessageId]"
                          out-map="context" />
        </actions>
    </service>

    <service verb="queue" noun="CreateFulfillmentSystemMessage">
        <description>Service to register a fulfillment for a order</description>
        <in-parameters>
            <parameter name="shipmentId" required="true" />
        </in-parameters>
        <actions>
            <set field="line_items" from="[]"/>
            <set field="fulfillment" from="[:]"/>
           
            <entity-find-one entity-name="mantle.shipment.Shipment" value-field="shipment">
                <field-map field-name="shipmentId" />
            </entity-find-one>
            <!-- the shipment is validated if exist-->
            <if condition="!shipment">
                <return error="true" message="The shipment ${shipment} does not exist" />
            </if>

            <if condition="shipment.statusId != 'ShipShipped'">
                <return error="true" message="The shipment ${shipmentId} must be in status Shipped to register a fulfillment "/>
            </if>

             <!-- get the store id -->
             <service-call name="mantle.shopify.ShopifyServices.get#LocationId" out-map="context"   in-map="[remoteId:'DEMO_SHOPIFY_SET_INVENTORY_REMOTE']"/>
             <service-call name="mantle.shipment.ShipmentServices.get#ShipmentDisplayInfo" in-map="[shipmentId:shipmentId]" out-map="context"/>


             <set field = "orderId" from="shipmentItemSourceList.first().orderId"/>
             <entity-find-one entity-name="mantle.order.OrderHeader" value-field="orderHeader">
                <field-map field-name="orderId" />
            </entity-find-one>
            
            <entity-find entity-name="mantle.order.OrderItem" list="orderItems">
                <econdition field-name="orderId"  from="orderId"/>
                <econdition field-name="itemTypeEnumId"  value="ItemProduct"/>
                <econdition field-name="quantity"   operator="greater" value="0"/>
            </entity-find>

            <iterate list="allShipmentPackageContentList" entry="item">
                <script>
                    def productTemp = orderItems.find{it.productId == item.productId}
                    def items = [:]
                    items.id = productTemp.externalItemSeqId
                    items.quantity = item.quantity
                    line_items.add(items)
                </script>
            </iterate>
           
            <set field="externalId" from="orderHeader.externalId" />
            <set field="fulfillment.location_id" from="locationId" />
            <set field="fulfillment.tracking_number" from="packageRouteSegList[0].trackingCode" />
            <set field="fulfillment.line_items" from="line_items" />
            <set field="messageText" from="groovy.json.JsonOutput.toJson([
                fulfillment : fulfillment
            ])"/>

            <!-- The service to create fulfillment is called only if  there are items were shipped -->
            <if condition="line_items">
                <service-call name="org.moqui.impl.SystemMessageServices.queue#SystemMessage" out-map="context"
                in-map="[systemMessageTypeId:'ShopifyCreateFulfillmentMessage', systemMessageRemoteId:'DEMO_SHOPIFY_CREATE_FULFILLMENT_REMOTE',
                    messageText:messageText,docSubControl: 'createFulfillment',docControl:externalId]"/>
            </if>
        </actions>
    </service>

    <service verb="send" noun="CreateFulfillmentSystemMessage">
        <implements service="org.moqui.impl.SystemMessageServices.send#SystemMessage"/>
        <in-parameters>
            <parameter name="systemMessageId" required="true"/>
        </in-parameters>
        <actions>
            <service-call name="mantle.shopify.ApiServices.send#SystemMessageRest" 
                          in-map="[systemMessageId: systemMessageId]"
                          out-map="context" />
        </actions>
    </service>
    

    

        <service verb="queue" noun="CalculateRefundSystemMessage">
            <description>Service to calculate the refund and cancel one order</description>
            <in-parameters>
                <parameter name="orderId" required="true" />
            </in-parameters>
            <actions>

                <set field="refund_line_items" from="[]"/>
                <set field="refund" from="[:]"/>
                <set field="shipping" from="[:]"/>

                <entity-find-one entity-name="mantle.order.OrderHeader" value-field="orderHeader">
                    <field-map field-name="orderId" />
                </entity-find-one>
                <!-- the order is validated if exist-->
                <if condition="!orderHeader">
                    <return error="true" message="The order ${orderId} does not exist" />
                </if>
                <if condition="!orderHeader.externalId">
                    <return error="true" message="In order ${orderId} does not have externalId" />
                </if>
                <entity-find entity-name="mantle.order.OrderItem" list="orderItems">
                    <econdition field-name="orderId"  from="orderId"/>
                    <econdition field-name="itemTypeEnumId"  value="ItemProduct"/>
                    <econdition field-name="quantityCancelled"   operator="greater" value="0"/>
                </entity-find>

                <iterate list="orderItems" entry="item">
                    <script>
                        def items = [:]
                        items.line_item_id = item.externalItemSeqId
                        items.quantity = item.quantityCancelled
                        items.restock_type = 'cancel'
                        refund_line_items.add (items)
                    </script>
                </iterate>

                <set field="currencyUomId" from="orderHeader.currencyUomId" />
                <set field="shipping.full_refund" value="true"/>
                <set field="refund.shipping" from="shipping"/>
                <set field="refund.currency" from="currencyUomId"/>
                <set field="refund.refund_line_items" from="refund_line_items"/>
                <set field="externalId" from="orderHeader.externalId" />
                <set field="messageText" from="groovy.json.JsonOutput.toJson([
                    refund : refund
                ])"/>

                <!-- The service to cancel order is called only if exist items to cancel -->
                <if condition="refund_line_items">
                    <service-call name="org.moqui.impl.SystemMessageServices.queue#SystemMessage" out-map="context"
                    in-map="[systemMessageTypeId:'ShopifyCalculateRefundMessage', systemMessageRemoteId:'DEMO_SHOPIFY_CALCULATE_REFUND_REMOTE',
                        messageText:messageText,docSubControl: 'calculateRefund',docControl:externalId]"/>
                </if>
            </actions>
        </service>

        <service verb="send" noun="CalculateRefundSystemMessage">
            <implements service="org.moqui.impl.SystemMessageServices.send#SystemMessage"/>
            <in-parameters>
                <parameter name="systemMessageId" required="true"/>
            </in-parameters>
            <actions>
                <service-call name="mantle.shopify.ApiServices.send#SystemMessageRest" 
                            in-map="[systemMessageId: systemMessageId]"
                            out-map="context" />

                <set field="refund" from="[:]"/>
                <set field="shipping" from="[:]"/>
                <set field="refund_line_items" from="[]"/>
                <set field="transactions" from="[]"/>

                <iterate list="response.refund.refund_line_items" entry="item">
                    <script>
                        def items = [:]
                        items.line_item_id = item.line_item_id
                        items.quantity = item.quantity
                        items.restock_type = item.restock_type
                        items.location_id =  item.location_id
                        refund_line_items.add (items)
                    </script>
                </iterate>

                <iterate list="response.refund.transactions" entry="transaction">
                    <script>
                        def tx = [:]
                        tx.parent_id = transaction.parent_id
                        tx.amount = transaction.amount
                        tx.kind = 'refund'
                        tx.gateway =  transaction.gateway
                        transactions.add (tx)
                    </script>
                </iterate>
        
                <set field="shipping.full_refund" value="true"/>
                <set field="refund.currency" from="response.refund.currency"/>
                <set field="refund.shipping" from="shipping"/>
                <set field="refund.refund_line_items" from="refund_line_items"/>
                <set field="refund.transactions" from="transactions"/>

                <set field="externalId" from="response.refund.transactions[0].order_id" />

                <set field="messageText" from="groovy.json.JsonOutput.toJson([
                    refund : refund
                ])"/>

                <service-call name="org.moqui.impl.SystemMessageServices.queue#SystemMessage" out-map="context"
                    in-map="[systemMessageTypeId:'ShopifyCancelOrderMessage', systemMessageRemoteId:'DEMO_SHOPIFY_CANCEL_ORDER_REMOTE',
                    messageText:messageText,docSubControl: 'cancelOrder',docControl:externalId]"/> 
            </actions>
        </service>
</services>
