<?xml version="1.0" encoding="UTF-8"?>
<services xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
          xsi:noNamespaceSchemaLocation="http://moqui.org/xsd/service-definition-2.1.xsd">

    <service verb="send" noun="SystemMessageRest">
        <implements service="org.moqui.impl.SystemMessageServices.send#SystemMessage"/>
        <in-parameters>
            <parameter name="systemMessageId" required="true"/>
        </in-parameters>
        <out-parameters>
            <parameter name="response"/>
            <parameter name="systemMessage"/>
        </out-parameters>
        <actions>
            <entity-find-one entity-name="moqui.service.message.SystemMessage" value-field="systemMessage"/>
            <if condition="!systemMessage.systemMessageRemoteId">
                <entity-find-one entity-name="moqui.service.message.SystemMessageRemote" value-field="remote">
                    <field-map field-name="systemMessageTypeId" from="systemMessage.systemMessageTypeId"/>
                </entity-find-one>
                <set field="systemMessage.systemMessageRemoteId" from="remote.systemMessageRemoteId"/>
             </if>

            <set field="systemMessageType" from="systemMessage.'moqui.service.message.SystemMessageType'"/>
            <if condition="!systemMessage.systemMessageRemoteId">
                <return error="true"
                        message="System message ${systemMessageId} has no systemMessageRemoteId, not sending."/>
            </if>
            <set field="systemMessageRemote" from="systemMessage.'moqui.service.message.SystemMessageRemote'"/>
            <set field="docSubType" from="systemMessage.docSubType?:''"/>
            <set field="response" value=""/>
            <script>import groovy.json.JsonSlurper</script>
            <script><![CDATA[
                def jsonSlurper = new JsonSlurper()
                json = jsonSlurper.parseText(systemMessage.messageText)
                String urlExpand = ec.resource.expand(systemMessageRemote.sendUrl, "systemMessage", [remoteMessageId:systemMessage.systemMessageId,
                        systemMessageTypeId:systemMessage.systemMessageTypeId, systemMessageRemoteId:systemMessage.systemMessageRemoteId], false)
                logger.info("SENDING MESSAGE TEXT ${systemMessage.messageText}")
                org.moqui.util.RestClient restClient = ec.service.rest()
                if (docSubType.contains("delete")) {
                    if (systemMessage.docSubType?.contains('deleteCollection')) {
                        urlExpand = urlExpand + json.shopifyCollectionId + ".json"
                    }else if(systemMessage.docSubType?.contains('deleteCollect')){
                        urlExpand = urlExpand + json.collectId + ".json"
                    }else{
                        urlExpand = urlExpand + systemMessage.messageText + ".json"
                    }
                    logger.info("URL EXPAND ${urlExpand}")
                    restClient = ec.service.rest().method(org.moqui.util.RestClient.DELETE).uri(urlExpand)
                } else if (docSubType.contains("get")) {
                    if (systemMessage.docSubType?.contains('getOrder')) {
                        urlExpand = urlExpand + json.status
                    }else if(systemMessage.docSubType?.contains('getAddresses')){
                        urlExpand = urlExpand + json.shopifyCustomerId + '/addresses.json'
                    }else if (systemMessage.docSubType?.contains('getCollects') ){
                        urlExpand = urlExpand + json.shopifyId
                    }else{
                        urlExpand = urlExpand + systemMessage.messageText
                    }
                    logger.info("URL EXPAND ${urlExpand}")
                    restClient = ec.service.rest().method(org.moqui.util.RestClient.GET).uri(urlExpand)
                } else if (docSubType.contains("put")) {
                    if (systemMessage.docSubControl?.contains('putCustomer')) {
                        urlExpand = urlExpand + systemMessage.docControl + ".json"
                    }
                    if (systemMessage.docSubControl?.contains('putProduct')) {
                        urlExpand = urlExpand + json.product.id + ".json"
                    }
                    logger.info("URL EXPAND ${urlExpand}")
                    restClient = ec.service.rest().method(org.moqui.util.RestClient.PUT).uri(urlExpand)
                            .addHeader("Content-Type", "application/json").jsonObject(systemMessage.messageText)
                } else {
                    if (systemMessage.docSubControl?.contains('cancelOrder')) {
                        urlExpand = urlExpand + systemMessage.shopifyOrderId + "/cancel.json"
                    }
                    if (systemMessage.docSubControl?.contains('calculateRefund')) {
                        urlExpand = urlExpand + systemMessage.shopifyOrderId + "/refunds/calculate.json"
                    }
                    if (systemMessage.docSubControl?.contains('createRefund')) {
                        urlExpand = urlExpand + systemMessage.shopifyOrderId + "/refunds.json"
                    }    
                    if (systemMessage.docSubControl?.contains('createFulfillment')) {
                        urlExpand = urlExpand + systemMessage.shopifyOrderId + "/fulfillments.json"
                    }
                    logger.info("URL EXPAND ${urlExpand}")
                    restClient = ec.service.rest().method(org.moqui.util.RestClient.POST).uri(urlExpand)
                            .addHeader("Content-Type", "application/json").jsonObject(systemMessage.messageText)
                }

                restClient.basicAuth(systemMessageRemote.username,systemMessageRemote.password)
                org.moqui.util.RestClient.RestResponse restResponse = restClient.call()
                if (restResponse.statusCode < 200 || restResponse.statusCode >= 300) {
                    String errMsg = restResponse.text()
                    ec.message.addError("System message ${systemMessageId} send error response (${restResponse.statusCode}): ${errMsg}")
                    return
                }
                response = jsonSlurper.parseText(restResponse.text())
            ]]></script>

            <!-- TODO: WebFacadeImpl.handleSystemMessage() will need to return a message ID before we can do this: <set field="remoteMessageId" from=""/> -->
        </actions>
    </service>

    <service verb="get" noun="ProductData">
        <in-parameters>
            <parameter name="productId" required="true"/>
        </in-parameters>
        <out-parameters>
            <parameter name="productData"/>
            <parameter name="product"/>
            <parameter name="error"/>
        </out-parameters>
        <actions>
            <script>import groovy.json.JsonSlurper</script>

            <entity-find-one entity-name="mantle.product.Product" value-field="product">
                <field-map field-name="productId" />
                <field-map field-name="productTypeEnumId"  value="PtVirtual"/>
            </entity-find-one>
            
            <if condition="!product">
                <message type="warning">The product ${productId} does not exist</message>
                <set field="error" value="true"/>
                <return/>
            </if>

            <if condition="product.productTypeEnumId != 'PtVirtual' ">
                <message type="warning">The product ${productId}  is not a virtual product</message>
                <set field="error" value="true"/>
                <return/>
            </if>

            <entity-find-one entity-name="mantle.product.ProductContent" value-field="productContent">
                <field-map field-name="productId"/>
                <field-map field-name="productContentTypeEnumId" value="PcntImageDetail"/>
            </entity-find-one>

            <if condition="!productContent">
                 <set field="error" value="true"/>
                 <message type="warning">The product ${productId}  does not have image associated, add one in Content section</message>
                 <return/>
            </if>

            <set field="images" from="[]"/>
            <set field="prodVariants" from="[]"/>
            <set field="prodOptions" from="[]"/>
            <set field="prodOptionsMap" from="new HashMap()"/>

            <service-call name="mantle.shopify.ShopifyServices.get#LocationAndStoreId" out-map="context"   in-map="[systemMessageTypeId:'ShopifyProductMessage']"/>
            <entity-find-one entity-name="mantle.product.store.ProductStore" value-field="productStore"/>
            <entity-find entity-name="mantle.product.store.ProductStoreSetting" list="productImageLocationList">
                <date-filter/>
                <econdition field-name="productStoreId" from="productStoreId"/>
                <econdition field-name="settingTypeEnumId" value="PsstProductImageUrl"/>
            </entity-find>

            <if condition="productImageLocationList.size()>0">
                <then>
                    <set field="productImageLocation" from="productImageLocationList.first()"/>
                </then>
                <else>
                    <set field="error" value="true"/>
                    <message type="warning">The product ${productId}  does not have url configured to display the image, please contact the administrator to setup one</message>
                    <return/>
                </else>
            </if>

            <set field="storeDomain" from ="productStore.storeDomain"/>
            <set field="productContentId" from ="productContent.productContentId"/>

            <set field="imageSettings" from="[storeDomain:storeDomain, productContentId:productContentId, productId:productId]"/>
            <set field="imageUrl" from="ec.resource.expand(productImageLocation.settingValue, null, imageSettings, false)"/>

            <if condition="productContent">
                <set field="image" from="[src: imageUrl]"/>
                <script>images.add(image)</script>
            </if>
            <if condition="product.productTypeEnumId == 'PtVirtual'">
                <then>
                    <!-- Get all the products associated to the parent product /-->
                    <entity-find entity-name="mantle.product.ProductAssoc" list="assocList">
                        <econdition field-name="productId"/>
                        <econdition field-name="fromDate" operator="is-not-null"/>
                        <econdition field-name="thruDate" operator="is-null"/>
                    </entity-find>

                    <if condition="assocList.size() == 0">
                        <set field="error" value="true"/>
                        <message type="warning">The product ${productId} does not have a product associated, add one kind of 'Product Variant' in the Associated section</message>
                        <return/>
                    </if>

                    <iterate list="assocList" entry="assoc">
                        <!-- Each product associated has at least one feature so we get all possible features /-->
                        <entity-find entity-name="mantle.product.feature.ProductAndFeatureAndFeatureAppl" list="featureList">
                            <econdition field-name="productId" from="assoc.toProductId"/>
                            <econdition field-name="fromDate" operator="is-not-null"/>
                            <econdition field-name="thruDate" operator="is-null"/>
                            <order-by field-name="productFeatureDescription"/>
                        </entity-find>

                        <if condition="featureList.size() == 0">
                            <set field="error" value="true"/>
                            <message type="warning">The associated product ${assoc.toProductId}  must have at least one Features, add one in Features section </message>
                            <return/>
                        </if>

                        <service-call name="mantle.product.PriceServices.get#ProductPrice" out-map="priceSet" in-map="[productId:assoc.toProductId]"/>

                        <entity-find-one entity-name="mantle.product.ProductIdentification" value-field="prodUPC">
                            <field-map field-name="productId" from="assoc.toProductId"/>
                            <field-map field-name="productIdTypeEnumId" value="PidtUpca"/>
                        </entity-find-one>

                        <entity-find-one entity-name="mantle.product.ProductDimension" value-field="productDimension">
                            <field-map field-name="productId" from="assoc.toProductId"/>
                        </entity-find-one>

                        <entity-find-one entity-name="moqui.basic.Uom" value-field="uom">
                            <field-map field-name="uomId" from="productDimension.valueUomId"/>
                        </entity-find-one>

                        <if condition="!prodUPC">
                            <set field="error" value="true"/>
                            <message type="warning">The associated product ${assoc.toProductId} does not have an identification, add one like UPC-A or SKU in the Identification section</message>
                            <return/>
                        </if>

                        <entity-find-one entity-name="mantle.product.ProductIdentification" value-field="prodSKU">
                            <field-map field-name="productId" from="assoc.toProductId"/>
                            <field-map field-name="productIdTypeEnumId" value="PidtSku"/>
                        </entity-find-one>

                        <if condition="!prodSKU">
                            <set field="error" value="true"/>
                            <message type="warning">The associated product ${assoc.toProductId} does not have a SKU identification, add one in the Identification section</message>
                            <return/>
                        </if>
                       
                        <script><![CDATA[
                            /**
                                The featureList is the list of all the features that an assoc has,
                                if it's only one feature, we don't need to make the combinations
                                if it the product has more than one feature we have to make the combinations
                                in order to follow the shopify format.

                                NOTE: Shopify supports products that has at most 3 features.
                            **/

                            variant = [:]
                            variant.name = featureList[0]?.productFeatureDescription
                            variant.option1 = variant.name
                            variant.option2 = featureList[1]?.productFeatureDescription
                            variant.option3 = featureList[2]?.productFeatureDescription
                            variant.price = priceSet.price
                            variant.inventory_management = 'shopify'
                            variant.barcode = prodUPC.idValue
                            variant.weight = productDimension.value
                            variant.weight_unit = uom.abbreviation
                            variant.sku = prodSKU.idValue

                            if(featureList.size() == 1){
                                prodVariants.add(new HashMap([name:variant.name,
                                                              option1:variant.option1,
                                                              price:variant.price,
                                                              inventory_management:variant.inventory_management,
                                                              barcode:variant.barcode,
                                                              weight:variant.weight,
                                                              weight_unit:variant.weight_unit,
                                                              sku:variant.sku]))
                            }else if(featureList.size() == 2){
                                prodVariants.add(new HashMap([name:variant.name + "/" + variant.option2,
                                                              option1:variant.option1,
                                                              option2:variant.option2,
                                                              price:variant.price,
                                                              inventory_management:variant.inventory_management,
                                                              barcode:variant.barcode,
                                                              weight:variant.weight,
                                                              weight_unit:variant.weight_unit,
                                                              sku:variant.sku]))
                            }else if(featureList.size() == 3){
                                prodVariants.add(new HashMap([name:variant.name + "/" + variant.option2 + "/" + variant.option3,
                                                              option1:variant.option1,
                                                              option2:variant.option2,
                                                              option3:variant.option3,
                                                              price:variant.price,
                                                              inventory_management:variant.inventory_management,
                                                              barcode: variant.barcode,
                                                              weight:variant.weight,
                                                              weight_unit:variant.weight_unit,
                                                              sku:variant.sku]))
                            }
                        ]]>
                        </script>
                        <iterate list="featureList" entry="feature">
                            <set field="item" from="feature.productFeatureTypeEnumId"/>
                            <script><![CDATA[
                                def optionSet = prodOptionsMap.get(item)
                                if (!optionSet) {
                                    prodOptionsMap.put(item, [feature.productFeatureDescription])
                                } else {
                                    if(!optionSet.contains(feature.productFeatureDescription)){
                                       optionSet.add(feature.productFeatureDescription)
                                    }
                                }
                            ]]></script>
                        </iterate>
                        <!-- MAKE THE COMBINATIONS FOR THE PRODUCT WITH THE FEATURELIST  /-->
                    </iterate>
                    <script><![CDATA[
                        String[] keyList = prodOptionsMap.keySet()
                        if(keyList.length == 1){
                            def options1 = prodOptionsMap.get(keyList[0])
                            prodOptions.add(new HashMap([name:keyList[0], values:options1]))
                        }else if(keyList.length == 2){
                            def options1 = prodOptionsMap.get(keyList[0])
                            def options2 = prodOptionsMap.get(keyList[1])
                            prodOptions.add(new HashMap([name:keyList[0], values:options1]))
                            prodOptions.add(new HashMap([name:keyList[1], values:options2]))
                        }else if(keyList.length == 3){
                            def options1 = prodOptionsMap.get(keyList[0])
                            def options2 = prodOptionsMap.get(keyList[1])
                            def options3 = prodOptionsMap.get(keyList[2])
                            prodOptions.add(new HashMap([name:keyList[0], values:options1]))
                            prodOptions.add(new HashMap([name:keyList[1], values:options2]))
                            prodOptions.add(new HashMap([name:keyList[2], values:options3]))
                        }
                    ]]></script>
                    <log message="OPTIONS ${prodOptions}"/>
                </then>
            </if>
            <set field="productData" from="[title: product.productName,
                                        body_html: '',
                                        vendor: '',
                                        images: images,
                                        variants: prodVariants,
                                        options: prodOptions]"/>
        </actions>
    </service>

    <service verb="queue" noun="ProductSystemMessage">
        <in-parameters>
            <parameter name="productId" required="true"/>
        </in-parameters>
        <actions>
            <service-call name="mantle.shopify.ApiServices.get#ProductData" 
                          in-map="[productId: productId, productStoreId: productStoreId]"
                          out-map="context" />

            <set field="json" from="groovy.json.JsonOutput.toJson([product: productData])"/>

            <entity-find-one entity-name="mantle.product.ProductIdentification" value-field="productForCreate">
                <field-map field-name="productId" />
                <field-map field-name="productIdTypeEnumId"  value="PidtShopify"/>
            </entity-find-one>
            
            <if condition="productForCreate">
                <message type="warning">The product ${productId}  already exist</message>
                <return/>
            </if>

            <if condition="error">
                <return/>
            </if>
            <service-call name="org.moqui.impl.SystemMessageServices.queue#SystemMessage" out-map="context"
                    in-map="[systemMessageTypeId:'ShopifyProductMessage', messageText:json, sentproductId:productId]"/>
        </actions>
    </service>

    <service verb="send" noun="ProductSystemMessage">
        <implements service="org.moqui.impl.SystemMessageServices.send#SystemMessage"/>
        <in-parameters>
            <parameter name="systemMessageId" required="true"/>
        </in-parameters>
        <actions>
            <service-call name="mantle.shopify.ApiServices.send#SystemMessageRest" 
                          in-map="[systemMessageId: systemMessageId]"
                          out-map="context" />
                          
            <if condition="response.product.variants.size &gt; 0">
                <set field="shopifyVariants" from="response.product.variants"/>
                <log message="VARIANTS ${shopifyVariants}"/>
                <iterate list="shopifyVariants" entry="shopifyVariant">
                    <entity-find entity-name="mantle.product.ProductIdentification" list="prodUPCs">
                        <econdition field-name="idValue" from="shopifyVariant.barcode"/>
                    </entity-find>
                    <set field="productId" from="prodUPCs.first().productId"/>
                    <service-call name="create#mantle.product.ProductIdentification" out-map="context" in-map="[productId:productId, productIdTypeEnumId:'PidtVariantShopify', idValue: shopifyVariant.id]"/>
                    <service-call name="create#mantle.product.ProductIdentification" out-map="context" in-map="[productId:productId, productIdTypeEnumId:'PidtInventoryItemShopify', idValue: shopifyVariant.inventory_item_id]"/>
                </iterate>
            </if>
            <service-call name="create#mantle.product.ProductIdentification" out-map="context" in-map="[productId:systemMessage.sentproductId, productIdTypeEnumId:'PidtShopify', idValue: response.product.id]"/>
        </actions>
    </service>


    <service verb="queue" noun="UpdateStatusProductSystemMessage">
        <in-parameters>
            <parameter name="productId" required="true"/>
        </in-parameters>
        <actions>
            <set field="productRequest" from="[:]"/>

            <service-call name="mantle.shopify.ShopifyServices.validate#ProductData" out-map="context"   in-map="[productId:productId]"/>
            <if condition="error"><return/></if>

            <set field="currentDate" from="ec.user.nowTimestamp"/>
            <set field="salesDiscontinuationDate" from="product.salesDiscontinuationDate"/>

            <set field="productRequest.id" from="productIdentification.idValue"/>

            <if condition="currentDate>=salesDiscontinuationDate">
                <set field="productRequest.status" value="archived"/>
                <set field="json" from="groovy.json.JsonOutput.toJson([product: productRequest])"/>
                <service-call name="org.moqui.impl.SystemMessageServices.queue#SystemMessage" out-map="context"
                              in-map="[systemMessageTypeId:'ShopifyUpdateProductMessage', messageText:json, docSubType:'put', docSubControl:'putProduct']"/>
            </if>
        </actions>
    </service>

    <service verb="send" noun="UpdateStatusProductSystemMessage">
        <implements service="org.moqui.impl.SystemMessageServices.send#SystemMessage"/>
        <in-parameters>
            <parameter name="systemMessageId" required="true"/>
        </in-parameters>
        <actions>
            <service-call name="mantle.shopify.ApiServices.send#SystemMessageRest"
                          in-map="[systemMessageId: systemMessageId]"
                          out-map="context" />
        </actions>
    </service>

    <service verb="get" noun="ProductCategoryData">
        <in-parameters>
            <parameter name="productCategoryId" required="true"/>
        </in-parameters>
        <out-parameters>
            <parameter name="productCategoryData"/>
            <parameter name="error"/>
        </out-parameters>
        <actions>
            <entity-find-one entity-name="mantle.product.category.ProductCategory" value-field="productCategory">
                <field-map field-name="productCategoryId"/>
            </entity-find-one>

            <if condition="!productCategory">
                <set field="error" value="true"/>
                <message type="warning">The product category ${productCategoryId} does not exist</message>
                <return/>
           </if>
           <if condition="productCategory.pseudoId != productCategory.productCategoryId">
                <set field="error" value="true"/>
                <message type="warning">The product category ${productCategoryId} already exists</message>
                <return/>
           </if>

            <entity-find entity-name="mantle.product.category.ProductCategoryMember" list="productCategoryMembers">
                <econdition field-name="productCategoryId"/>
                <econdition field-name="thruDate" from="null"/>
            </entity-find>

            <script>import groovy.json.JsonSlurper</script>
            <set field="shopifyCollectItems" from="[]"/>
            <!-- 
                if the product category has members those members are added to current category
                otherwise only the category is created
            -->
            <iterate list="productCategoryMembers" entry="productCategoryMember">
                <entity-find-one entity-name="mantle.product.ProductIdentification" value-field="productIdentification">
                    <field-map field-name="productId" from="productCategoryMember.productId"/>
                    <field-map field-name="productIdTypeEnumId" value="PidtShopify"/>
                </entity-find-one>
                <if condition="productIdentification">
                    <script>
                        <![CDATA[
                            shopifyCollectItems.add(new HashMap([product_id:productIdentification.idValue]))
                        ]]>
                    </script>
                </if>
            </iterate>
            <if condition="shopifyCollectItems.size &gt; 0"><then>
                <set field="productCategoryData" from="[title: productCategory.categoryName, collects: shopifyCollectItems]"/>
            </then><else>
                <set field="productCategoryData" from="[title: productCategory.categoryName]"/>
            </else></if>
        </actions>
    </service>

    <service verb="queue" noun="CreateCollectionSystemMessage">
        <in-parameters>
            <parameter name="productCategoryId" required="true"/>
        </in-parameters>
        <actions>
            <service-call name="mantle.shopify.ApiServices.get#ProductCategoryData"
                          in-map="[productCategoryId: productCategoryId, productStoreId: productStoreId]"
                          out-map="context" />

            <set field="json" from="groovy.json.JsonOutput.toJson([custom_collection: productCategoryData])"/>
            <if condition="error">
                <return/>
            </if>
            <service-call name="org.moqui.impl.SystemMessageServices.queue#SystemMessage" out-map="context"
                          in-map="[systemMessageTypeId:'ShopifyCreateCollectionMessage', messageText:json, sentProductCategoryId:productCategoryId]"/>
        </actions>
    </service>

    <service verb="send" noun="CreateCollectionSystemMessage">
        <implements service="org.moqui.impl.SystemMessageServices.send#SystemMessage"/>
        <in-parameters>
            <parameter name="systemMessageId" required="true"/>
        </in-parameters>
        <actions>
            <service-call name="mantle.shopify.ApiServices.send#SystemMessageRest"
                          in-map="[systemMessageId: systemMessageId]"
                          out-map="context" />
            <set field="shopifyId" from="response.custom_collection.id"/>
            <service-call name="mantle.shopify.ApiServices.queue#GetCollectsSystemMessage" out-map="context"
                          in-map="[productCategoryId:systemMessage.sentProductCategoryId,shopifyId:shopifyId]"/>
        </actions>
    </service>

    <service verb="queue" noun="GetCollectsSystemMessage">
        <in-parameters>
            <parameter name="productCategoryId" required="true"/>
            <parameter name="shopifyId" required="true"/>
        </in-parameters>
        <actions>
            <service-call name="update#mantle.product.category.ProductCategory" out-map="context" in-map="[productCategoryId:productCategoryId, pseudoId:shopifyId]" transaction="ignore"/>
            <set field="messageText" from="groovy.json.JsonOutput.toJson([shopifyId:shopifyId])"/>
            <service-call name="org.moqui.impl.SystemMessageServices.queue#SystemMessage" out-map="context"
                          in-map="[systemMessageTypeId:'ShopifyGetCollectsMessage', messageText:messageText, sentProductCategoryId:productCategoryId, docSubType: 'getCollects']"/>
        </actions>
    </service>

    <service verb="send" noun="GetCollectsSystemMessage">
        <implements service="org.moqui.impl.SystemMessageServices.send#SystemMessage"/>
        <in-parameters>
            <parameter name="systemMessageId" required="true"/>
        </in-parameters>
        <actions>
            <service-call name="mantle.shopify.ApiServices.send#SystemMessageRest"
                          in-map="[systemMessageId: systemMessageId]"
                          out-map="context"/>

            <entity-find entity-name="mantle.product.category.ProductCategoryMember" list="productCategoryMembers">
                <econdition field-name="productCategoryId" from="systemMessage.sentProductCategoryId"/>
                <econdition field-name="thruDate" from="null"/>
            </entity-find>
             <iterate list="productCategoryMembers" entry="productCategoryMember">
                <entity-find-one entity-name="mantle.product.ProductIdentification" value-field="productIdentification">
                    <field-map field-name="productId" from="productCategoryMember.productId"/>
                    <field-map field-name="productIdTypeEnumId" value="PidtShopify"/>
                </entity-find-one>
                <if condition="productIdentification">
                    <set field="collect" from="response.collects.find{it.product_id.toString().equals(productIdentification.idValue.toString())}"/>
                </if>
                <if condition="collect">
                    <service-call name="update#mantle.product.category.ProductCategoryMember" out-map="context" in-map="[productId:productCategoryMember.productId, productCategoryId:productCategoryMember.productCategoryId, fromDate:productCategoryMember.fromDate, shopifyId:collect.id]"/>
                </if>
            </iterate>
        </actions>
    </service>

    <service verb="queue" noun="DeleteCollectionSystemMessage">
        <in-parameters>
            <parameter name="productCategoryId" required="true"/>
        </in-parameters>
        <actions>
            
            <entity-find-one entity-name="mantle.product.category.ProductCategory" value-field="productCategory">
                <field-map field-name="productCategoryId"/>
            </entity-find-one>
            <if condition="!productCategory">
                <message type="warning">The product category ${productCategoryId} does not exist</message>
                <return/>
            </if>

            <if condition="productCategory.pseudoId ==  productCategory.productCategoryId">
                <message type="warning">The product category ${productCategoryId} was already deleted</message>
                <return/>
            </if>

            <set field="shopifyCollectionId" from="productCategory.pseudoId"/>
            <set field="messageText" from="groovy.json.JsonOutput.toJson([shopifyCollectionId:shopifyCollectionId])"/>
            <service-call name="org.moqui.impl.SystemMessageServices.queue#SystemMessage" out-map="context"
                          in-map="[systemMessageTypeId:'ShopifyDeleteCollectionMessage', messageText:messageText, sentProductCategoryId:productCategoryId, docSubType: 'deleteCollection']"/>
        </actions>
    </service>

    <service verb="send" noun="DeleteCollectionSystemMessage">
        <implements service="org.moqui.impl.SystemMessageServices.send#SystemMessage"/>
        <in-parameters>
            <parameter name="systemMessageId" required="true"/>
        </in-parameters>
        <actions>
            <service-call name="mantle.shopify.ApiServices.send#SystemMessageRest"
                          in-map="[systemMessageId: systemMessageId]"
                          out-map="context" />
            <service-call name="update#mantle.product.category.ProductCategory" out-map="context" in-map="[productCategoryId:systemMessage.sentProductCategoryId, pseudoId:'']"/>

            <entity-find entity-name="mantle.product.category.ProductCategoryMember" list="productCategoryMembers">
                <econdition field-name="productCategoryId" from="systemMessage.sentProductCategoryId"/>
                <econdition field-name="thruDate" from="null"/>
            </entity-find>
            <iterate list="productCategoryMembers" entry="productCategoryMember">
                <service-call name="update#mantle.product.category.ProductCategoryMember" out-map="context" in-map="productCategoryMember + [shopifyId:'']"/>
            </iterate>
        </actions>
    </service>

    <service verb="get" noun="ProductCategoryMemberData">
        <in-parameters>
            <parameter name="productCategoryId" required="true"/>
            <parameter name="productId" required="true"/>
        </in-parameters>
        <out-parameters>
            <parameter name="collectData"/>
            <parameter name="error"/>
        </out-parameters>
        <actions>
            <entity-find-one entity-name="mantle.product.category.ProductCategory" value-field="productCategory">
                <field-map field-name="productCategoryId" from="productCategoryId"/>
            </entity-find-one>
            
            <if condition="!productCategory">
                <set field="error" value="true"/>
                <message type="warning">The product category ${productCategoryId} does not exist</message>
                <return/>
            </if>
            <if condition="productCategory.pseudoId == productCategory.productCategoryId">
                <set field="error" value="true"/>
                <message type="warning">The product category ${productCategoryId} does not have shopifyId</message>
                <return/>
            </if>

            <entity-find-one entity-name="mantle.product.ProductIdentification" value-field="productIdentification">
                <field-map field-name="productId" from="productId"/>
                <field-map field-name="productIdTypeEnumId" value="PidtShopify"/>
            </entity-find-one>

            <if condition="!productIdentification">
                <set field="error" value="true"/>
                <message type="warning">The product ${productId} must be a virtual product</message>
                <return/>
            </if>

            <entity-find entity-name="mantle.product.category.ProductCategoryMember" list="productCategoryMembers">
                <econdition field-name="productCategoryId" from="productCategoryId"/>
                <econdition field-name="productId" from="productId"/>
                <econdition field-name="thruDate" from="null"/>
            </entity-find>

            <if condition="productCategoryMembers.size() == 0">
                <set field="error" value="true"/>
                <message type="warning">The product ${productId} does not have this category ${productCategoryId} setup , please setup it on Categories Section tab in  EditProduct screen</message>
                <return/>
            </if>

            <set field="collectData" from="[:]"/>
            <if condition="productIdentification">
                <script>
                    <![CDATA[
                        collectData = [product_id:productIdentification.idValue, collection_id:productCategory.pseudoId]
                    ]]>
                </script>
            </if>
        </actions>
    </service>

    <service verb="queue" noun="CreateCollectSystemMessage">
        <in-parameters>
            <parameter name="productCategoryId" required="true"/>
            <parameter name="productId" required="true"/>
        </in-parameters>
        <actions>
            <service-call name="mantle.shopify.ApiServices.get#ProductCategoryMemberData"
                          in-map="[productCategoryId: productCategoryId, productId: productId]"
                          out-map="context" />

            <set field="json" from="groovy.json.JsonOutput.toJson([collect: collectData])"/>
            
            <if condition="error">
                <return/>
            </if>
            <service-call name="org.moqui.impl.SystemMessageServices.queue#SystemMessage" out-map="context"
                          in-map="[systemMessageTypeId:'ShopifyCreateCollectMessage', messageText:json, sentProductCategoryId:productCategoryId, sentproductId:productId]"/>
        </actions>
    </service>

    <service verb="send" noun="CreateCollectSystemMessage">
        <implements service="org.moqui.impl.SystemMessageServices.send#SystemMessage"/>
        <in-parameters>
            <parameter name="systemMessageId" required="true"/>
        </in-parameters>
        <actions>
            <service-call name="mantle.shopify.ApiServices.send#SystemMessageRest"
                          in-map="[systemMessageId: systemMessageId]"
                          out-map="context" />

            <entity-find entity-name="mantle.product.category.ProductCategoryMember" list="productCategoryMembers">
                <econdition field-name="productCategoryId" from="systemMessage.sentProductCategoryId"/>
                <econdition field-name="productId" from="systemMessage.sentproductId"/>
                <econdition field-name="thruDate" from="null"/>
            </entity-find>
            <set field="productCategoryMember" from="productCategoryMembers.first()"/>
            <service-call name="update#mantle.product.category.ProductCategoryMember" out-map="context" in-map="[productId:productCategoryMember.productId, productCategoryId:productCategoryMember.productCategoryId, fromDate:productCategoryMember.fromDate, shopifyId:response.collect.id]"/>
        </actions>
    </service>

    <service verb="queue" noun="DeleteCollectSystemMessage">
        <in-parameters>
            <parameter name="productCategoryId" required="true"/>
            <parameter name="productId" required="true"/>
        </in-parameters>
        <actions>
            <entity-find-one entity-name="mantle.product.category.ProductCategoryMember" value-field="productCategoryMember">
                <field-map field-name="productCategoryId" from="productCategoryId"/>
                <field-map field-name="productId" from="productId"/>
                <field-map field-name="thruDate" from="null"/>
            </entity-find-one>

            <if condition="!productCategoryMember?.shopifyId">
                <message type="warning">The collection does not exist</message>
                <return/>
            </if>
            <set field="messageText" from="groovy.json.JsonOutput.toJson([collectId:productCategoryMember.shopifyId])"/>
            <service-call name="org.moqui.impl.SystemMessageServices.queue#SystemMessage" out-map="context"
                          in-map="[systemMessageTypeId:'ShopifyDeleteCollectMessage', messageText:messageText, sentProductCategoryId:productCategoryId, sentproductId:productId, docSubType: 'deleteCollect']"/>
        </actions>
    </service>

    <service verb="send" noun="DeleteCollectSystemMessage">
        <implements service="org.moqui.impl.SystemMessageServices.send#SystemMessage"/>
        <in-parameters>
            <parameter name="systemMessageId" required="true"/>
        </in-parameters>
        <actions>
            <service-call name="mantle.shopify.ApiServices.send#SystemMessageRest"
                          in-map="[systemMessageId: systemMessageId]"
                          out-map="context"/>

            <entity-find-one entity-name="mantle.product.category.ProductCategoryMember" value-field="productCategoryMember">
                <field-map field-name="productCategoryId" from="systemMessage.sentProductCategoryId"/>
                <field-map field-name="productId" from="systemMessage.sentproductId"/>
                <field-map field-name="thruDate" from="null"/>
            </entity-find-one>
            <service-call name="update#mantle.product.category.ProductCategoryMember" out-map="context" in-map="[productId:productCategoryMember.productId, productCategoryId:productCategoryMember.productCategoryId, fromDate:productCategoryMember.fromDate, shopifyId:'']"/>
        </actions>
    </service>
    
    <service verb="queue" noun="GetOrdersSystemMessage" authenticate="anonymous-all">
        <description> Get all order in paid status</description>
        <actions>
            <set field="messageText" from="groovy.json.JsonOutput.toJson([status:'paid'])"/>
            <service-call name="org.moqui.impl.SystemMessageServices.queue#SystemMessage" out-map="context"
                          in-map="[systemMessageTypeId:'ShopifyGetOrdersMessage', messageText: messageText, docSubType: 'getOrders']"/>
        </actions>
    </service>

    <service verb="send" noun="GetOrdersSystemMessage">
        <implements service="org.moqui.impl.SystemMessageServices.send#SystemMessage"/>
        <in-parameters>
            <parameter name="systemMessageId" required="true"/>
        </in-parameters>
        <actions>
            <service-call name="mantle.shopify.ApiServices.send#SystemMessageRest"
                          in-map="[systemMessageId: systemMessageId]"
                          out-map="context"/>
            <entity-find-one entity-name="moqui.service.message.SystemMessageRemote" value-field="systemMessageRemote">
                <field-map field-name="systemMessageRemoteId" from="systemMessage.systemMessageRemoteId"/>
            </entity-find-one>
            <entity-find-one entity-name="mantle.product.store.ProductStore" value-field="productStore">
                <field-map field-name="productStoreId" from="systemMessageRemote.productStoreId"/>
            </entity-find-one>

            <entity-find entity-name="mantle.order.OrderHeader" list="orderAlreadyCreated">
                <econdition field-name="statusId" value="OrderApproved"/>
            </entity-find>

            <!-- filtering orders that have not been dispatched yet -->
            <set field="orderPaidList" from="response.orders.findAll { it.fulfillment_status == null }"/>

            <set field="orderIdPaidList" from="orderPaidList*.id"/>

            <!-- filtering internal orders that have not been dispatched yet -->
            <set field="orderMoquiAlreadyCreated" from="orderAlreadyCreated*.externalId.findAll { it != null &amp;&amp; it != '' }"/>
            <set field="orderMoquiAlreadyCreated" from="orderMoquiAlreadyCreated.collect { it.toLong() }"/>
            <!-- filtering orders that need to be processed -->
            <set field="orderToProcess" from="orderIdPaidList -  orderMoquiAlreadyCreated"/>

            <set field="orderPaidtoProcess" from="orderPaidList.findAll { orderToProcess.contains(it.id) }"/>
            <iterate list="orderPaidtoProcess" entry="order">
                <set field="messageText" from="groovy.json.JsonOutput.toJson(order)"/>
                <service-call name="mantle.shopify.ShopifyServices.validate#AlreadyCreatedSystemMessage" in-map="[shopifyOrderId:order.id, 
                                                                                                                  systemMessageTypeId:'ShopifyGetOrdersMessage',
                                                                                                                  statusId:'SmsgReceived']" out-map="context"/>
                <if condition="systemMessageAlreadyExist">
                    <continue/>
                </if>
                <service-call name="create#moqui.service.message.SystemMessage" in-map="[systemMessageTypeId:'ShopifyGetOrdersMessage',
                                                                                         statusId:'SmsgReceived',
                                                                                         isOutgoing:'N',
                                                                                         parentMessageId:systemMessageId,
                                                                                         messageText:messageText,
                                                                                         docType:'json',
                                                                                         docSubType:'order',
                                                                                         shopifyOrderId:order.id,
                                                                                         shopifyDisplayOrderId:order.order_number,
                                                                                         initDate:ec.user.nowTimestamp]" out-map="context"/>
            </iterate>
        </actions>
    </service>

    <!-- consume order-->
    <service verb="consume" noun="OrdersSystemMessage">
        <implements service="org.moqui.impl.SystemMessageServices.send#SystemMessage"/>
        <in-parameters>
            <parameter name="systemMessageId" required="true"/>
        </in-parameters>
        <actions>
            <entity-find-one entity-name="moqui.service.message.SystemMessage" value-field="systemMessage" for-update="true"/>
            <entity-find-one entity-name="moqui.service.message.SystemMessageRemote" value-field="systemMessageRemote">
                <field-map field-name="systemMessageTypeId" from="systemMessage.systemMessageTypeId"/>
            </entity-find-one>
            <entity-find-one entity-name="mantle.product.store.ProductStore" value-field="productStore">
                <field-map field-name="productStoreId" from="systemMessageRemote.productStoreId"/>
            </entity-find-one>

            <set field="messageText" from="systemMessage.messageText.trim()"/>

            <if condition="systemMessage.docType == 'json' &amp;&amp; systemMessage.docSubType == 'order'">

                <set field="order" from="new groovy.json.JsonSlurper().parseText(messageText ?: '{}')"/>
                <set field="customer" from="order.customer"/>
                <set field="shippingAddress" from="order.shipping_address"/>
                <set field="billingAddress" from="order.billing_address"/>

                <if condition="order.shipping_lines.size() == 0">
                    <return error="true" message="ERROR: NO PRODUCTS FOUND ON SHOPIFY ORDER ${order.name} - ${order.id}"/>
                </if>

                <set field="carrierData" from="order.shipping_lines.first()"/>
                <set field="paymentDetails" from="order.payment_details"/>
                <set field="orderItems" from="order.line_items"/>
                <set field="discountApplications" from="order.discount_applications"/>

                <if condition="!customer">
                    <return error="true" message="ERROR: NO CUSTOMER FOUND ON SHOPIFY ORDER ${order.name} - ${order.id}"/>

                </if>
                <if condition="!shippingAddress">
                    <return error="true" message="ERROR: NO SHIPPING ADDRESS FOUND ON SHOPIFY ORDER ${order.name} - ${order.id}"/>
                </if>
                <if condition="!billingAddress">
                    <log message="NO BILLING ADDRESS FOUND ON RESPONSE, SHIPPING ADDRESS WILL BE ASSIGNED"/>
                    <set field="billingAddress" from="shippingAddress"/>
                </if>
                <if condition="!paymentDetails">
                    <return error="true" message="ERROR: NO PAYMENT DETAILS FOUND ON SHOPIFY ORDER ${order.name} - ${order.id}"/>
                </if>
                <if condition="!orderItems">
                    <return error="true" message="ERROR: NO ORDER ITEMS FOUND ON SHOPIFY ORDER ${order.name} - ${order.id}"/>
                </if>
                <if condition="!carrierData">
                    <return error="true" message="ERROR: NO CARRIER DATA FOUND ON SHOPIFY ORDER ${order.name} - ${order.id}"/>
                </if>
                
                <!-- GETTING CORRECT CARRIER DATA-->
                <entity-find entity-name="mantle.party.PartyIdentification" list="carrierList">
                    <econdition field-name="idValue" from="carrierData.source"/>
                    <econdition field-name="partyIdTypeEnumId" value="PtidCarrierShopify"/>
                </entity-find>

                <entity-find entity-name="moqui.basic.Enumeration" list="shopifyShippingMethods">
                    <econdition field-name="enumTypeId" value="ShopifyShippingMethod"/>
                </entity-find>

                <set field="shopifyShippingMethodIds" from="shopifyShippingMethods*.description"/>

                <if condition="carrierList.size() &gt; 0">
                    <then>
                        <set field="moquiCarrierData" from="carrierList.first()"/>
                        <if condition="carrierData.title in (shopifyShippingMethodIds)">
                            <then>
                                <set field="shippingMethod" value="Standard Shipping"/>
                            </then>
                            <else>
                                <set field="shippingMethod" from="carrierData.title"/>
                            </else>
                        </if>
                        <entity-find entity-name="mantle.shipment.carrier.CarrierShipmentMethod" list="shipmentMethodList">
                            <econdition field-name="description" from="shippingMethod"/>
                            <econdition field-name="carrierPartyId" from="moquiCarrierData.partyId"/>
                        </entity-find>
                        <if condition="shipmentMethodList.size() &gt; 0">
                            <then>
                                <set field="moquiShipmentMethod" from="shipmentMethodList.first()"/>
                            </then>
                            <else>
                                <return error="true" message="ERROR: THE SHIPMENT ${carrierData.title} METHOD SELECTED IS NOT REGISTER ON DB FOR SHOPIFY ORDER ${order.name} - ${order.id}"/>
                            </else>
                        </if>
                    </then>
                    <else>
                        <return error="true" message="ERROR: NO CARRIER FOUND ON DB FOR SHOPIFY ORDER ${order.name} - ${order.id}"/>
                    </else>
                </if>
                <service-call name="popstore.CustomerServices.find#PartyByEmail" in-map="[emailAddress:customer.email]" out-map="context"/>
                <entity-find-one entity-name="mantle.order.OrderHeader" value-field="createdOrder">
                    <field-map field-name="externalId" from="order.id"/>
                </entity-find-one>

                <if condition="createdOrder">
                    <return error="true" message="SHOPIFY ORDER #${order.order_number} ALREADY CREATED, WITH ORDER ID: ${createdOrder.orderId} ON DB"/>
                </if>
                
                <if condition="partyIds.size() &gt; 0">
                    <then>
                        <set field="partyId" from="partyIds.first()"/>
                    </then>
                    <else>
                        <service-call name="mantle.party.PartyServices.create#Person" in-map="[firstName:customer.first_name,
                                                                                                  lastName:customer.last_name,
                                                                                                  username: customer.email,
                                                                                                  emailAddress:customer.email]" out-map="context"/>
                        <service-call name="create#mantle.party.PartyIdentification" in-map="[partyId:partyId, partyIdTypeEnumId:'PtidShopify', idValue:customer.id]" out-map="context"/>
                        <service-call name="mantle.party.ContactServices.store#PartyContactInfo" in-map="[partyId:partyId, emailAddress:customer.email, emailContactMechPurposeId:'EmailPrimary']"/>
                        <log message="CUSTOMER CREATED ${partyId}"/>
                    </else>
                </if>
                    <entity-find entity-name="mantle.party.contact.PartyContactMechPostalAddress" list="postalMechList">
                        <econdition field-name="partyId" from="partyId"/>
                        <econdition field-name="contactMechPurposeId" value="PostalPrimary"/>
                        <econdition field-name="address1" from="shippingAddress?.address1"/>
                        <econdition field-name="address2" from="shippingAddress?.address2" ignore-case="true" ignore-if-empty="true"/>
                        <date-filter/>
                    </entity-find>
                    <entity-find entity-name="mantle.party.contact.PartyContactMechTelecomNumber" list="telecomMechList">
                        <econdition field-name="partyId" from="partyId"/>
                        <econdition field-name="contactMechPurposeId" value="PhonePrimary"/>
                    </entity-find>

                    <if condition="postalMechList.size() &gt; 0">
                        <then>
                            <set field="postalMech" from="postalMechList.first()"/>
                            <if condition="postalMech.address1.equals(shippingAddress?.address1 ?: '' ) || postalMech.address2.equals(shippingAddress?.address2 ?: '' )">
                                <set field="postalContactMechId" from="postalMech.contactMechId"/>
                                <log message="SHIPPING ADDRESS ALREADY EXISTS"/>
                            </if>
                        </then>
                        <else>
                            <entity-find entity-name="moqui.basic.Geo" list="shippingCountryList">
                                <econdition field-name="geoTypeEnumId" value="GEOT_COUNTRY"/>
                                <econdition field-name="geoCodeAlpha2" from="shippingAddress.country_code"/>
                            </entity-find>
                            <entity-find entity-name="moqui.basic.Geo" list="shippingStateList">
                                <econdition field-name="geoId" from="shippingCountryList.first().geoId + '_' + shippingAddress.province_code"/>
                                <econdition field-name="geoTypeEnumId" value="GEOT_STATE"/>
                                <econdition field-name="geoCodeAlpha2" from="shippingAddress.province_code"/>
                            </entity-find>
                            <entity-find entity-name="moqui.basic.Geo" list="billingCountryList">
                                <econdition field-name="geoTypeEnumId" value="GEOT_COUNTRY"/>
                                <econdition field-name="geoCodeAlpha2" from="billingAddress.country_code"/>
                            </entity-find>
                            <entity-find entity-name="moqui.basic.Geo" list="billingStateList">
                                <econdition field-name="geoId" from="billingCountryList.first().geoId + '_' + billingAddress.province_code"/>
                                <econdition field-name="geoTypeEnumId" value="GEOT_STATE"/>
                                <econdition field-name="geoCodeAlpha2" from="billingAddress.province_code"/>
                            </entity-find>
                            <service-call name="mantle.party.ContactServices.store#PartyContactInfo" in-map="[partyId: partyId,
                                                                                                          address1:shippingAddress.address1,
                                                                                                          address2:shippingAddress.address2,
                                                                                                          postalContactMechPurposeId: 'PostalPrimary',
                                                                                                          toName: shippingAddress.name,
                                                                                                          postalCode:shippingAddress.zip,
                                                                                                          countryGeoId: shippingCountryList.first().geoId,
                                                                                                          stateProvinceGeoId: shippingStateList.first().geoId,
                                                                                                          city: shippingAddress.city,
                                                                                                          emailAddress: customer.email]" out-map="shippingMechData"/>
                            <set field="postalContactMechId" from="shippingMechData.postalContactMechId"/>
                            <service-call name="mantle.party.ContactServices.store#PartyContactInfo" in-map="[partyId: partyId,
                                                                                                          address1:billingAddress.address1,
                                                                                                          address2:billingAddress.address2,
                                                                                                          postalContactMechPurposeId: 'PostalBilling',
                                                                                                          toName: billingAddress.name,
                                                                                                          postalCode:billingAddress.zip,
                                                                                                          countryGeoId: billingCountryList.first().geoId,
                                                                                                          stateProvinceGeoId: billingStateList.first().geoId,
                                                                                                          city: billingAddress.city,
                                                                                                          emailAddress: customer.email]" out-map="billingMechData"/>
                        </else>
                    </if>
                    <if condition="shippingAddress.phone">
                        <set field="contactNumber" from="shippingAddress.phone.replaceAll('-','')"/>
                        <set field="contactNumber" from="contactNumber.replaceAll('\\+','')"/>
                        <set field="phoneCountryCode" from="contactNumber.substring(0,3)"/>
                        <set field="phoneNumber" from="contactNumber.substring(3).replaceAll(' ','')"/>
                    </if>
                    <if condition="telecomMechList.size() &gt; 0">
                        <then>
                            <set field="telecomMech" from="telecomMechList.first()"/>
                            <if condition="telecomMech.contactNumber.equals(shippingAddress.phone)">
                                <set field="telecomContactMechId" from="telecomMech.contactMechId"/>
                                <log message="TELECOM NUMBER ALREADY EXISTS"/>
                            </if>
                        </then>
                        <else>
                            <service-call name="mantle.party.ContactServices.store#PartyContactInfo" in-map="[partyId: partyId,
                                                                                                          contactNumber: phoneNumber,
                                                                                                          countryCode: phoneCountryCode,
                                                                                                          telecomContactMechPurposeId:&apos;PhonePrimary&apos;]" out-map="telecomMechData"/>
                            <set field="telecomContactMechId" from="telecomMechData.telecomContactMechId"/>
                        </else>
                    </if>

                    <!-- Create order based on shopify data -->
                    <service-call name="mantle.order.OrderServices.create#Order" in-map="[productStoreId: productStore.productStoreId,
                                                                                  displayId: order.order_number,
                                                                                  externalId: order.id,
                                                                                  orderName: 'Shopify Order - ' + order.order_number,
                                                                                  disablePromotions:'Y',
                                                                                  disableShippingCalc:'Y',
                                                                                  disableTaxCalc:'Y',
                                                                                  salesChannelEnumId: 'ScShopify',
                                                                                  systemMessageRemoteId: systemMessageRemote.systemMessageRemoteId,
                                                                                  customerPartyId: partyId]" out-map="context"/>
                    <entity-find-one entity-name="mantle.order.OrderHeader" value-field="orderHeader"/>
                    <entity-find-one entity-name="mantle.order.OrderPart" value-field="orderPart"/>

                    <if condition="discountApplications.size() &gt; 0">
                        <set field="discount" from="discountApplications[0]"/>
                    </if>
                    
                    <!-- Adding product to created order -->
                    <iterate list="orderItems" entry="orderItem">
                        <entity-find entity-name="mantle.product.ProductIdentification" list="productIdList">
                            <econdition field-name="idValue" from="orderItem.variant_id"/>
                            <econdition field-name="productIdTypeEnumId" value="PidtVariantShopify"/>
                        </entity-find>
                        <if condition="productIdList.size() == 0">
                            <return error="true" message="ERROR: THE PRODUCT ID ${orderItem.variant_id} ON SHOPIFY ORDER ${order.name} IS NOT REGISTERED ON DB, PLEASE CONTACT ADMIN"/>
                        </if>
                        <if condition="orderHeader &amp;&amp; orderPart &amp;&amp; productIdList">
                            <set field="productId" from="productIdList.first().productId"/>
                            <service-call name="mantle.order.OrderServices.create#OrderItem" in-map="[orderId: orderHeader.orderId,
                                                                                            productId: productId,
                                                                                            orderPartSeqId: orderPart.orderPartSeqId,
                                                                                            externalItemSeqId: orderItem.id,
                                                                                            itemTypeEnumId: 'ItemProduct',
                                                                                            productStoreId: productStore.productStoreId,
                                                                                            quantity: orderItem.quantity,
                                                                                            unitAmount:orderItem.price]" out-map="context"/>
                            <!-- TAX APPLICATIONS -->
                            <set field="taxApplications" from="orderItem.tax_lines"/>
                            <if condition="taxApplications.size() &gt; 0">
                                <iterate list="taxApplications" entry="taxApplication">
                                    <set field="taxValue" from="Double.parseDouble(taxApplication.price)"/>
                                    <service-call name="mantle.order.OrderServices.create#OrderItem" in-map="[orderId: orderHeader.orderId,
                                                                                    orderPartSeqId: orderPart.orderPartSeqId,
                                                                                    itemTypeEnumId: 'ItemSalesTax',
                                                                                    productStoreId: productStore.productStoreId,
                                                                                    comments: taxApplication.title,
                                                                                    unitAmount:taxValue]" out-map="context"/>
                                </iterate>
                            </if>
                            <!-- DISCOUNTS APPLICATIONS -->
                            <if condition="orderItem.discount_allocations.size() &gt; 0">
                                        <service-call name="mantle.order.OrderServices.create#OrderItem" in-map="[orderId: orderHeader.orderId,
                                                                                        productId: productId,
                                                                                        orderItemSeqId: orderItemSeqId,
                                                                                        orderPartSeqId: orderPart.orderPartSeqId,
                                                                                        itemTypeEnumId: 'ItemDiscount',
                                                                                        quantity: 1,
                                                                                        productStoreId: productStore.productStoreId,
                                                                                        promoCodeText: discount.title,
                                                                                        unitAmount: Double.parseDouble(orderItem.discount_allocations[0].amount) * -1]" out-map="context"/>
                            </if>
                            <entity-find entity-name="mantle.order.OrderItem" list="orderItemList">
                                <econdition field-name="orderId" from="orderHeader.orderId"/>
                                <econdition field-name="productId" from="productId"/>
                            </entity-find>
                            <if condition="orderItemList">
                                <service-call name="update#mantle.order.OrderItem" out-map="context" in-map="orderItemList.first() + [externalItemSeqId:orderItem.id]"/>
                            </if>
                        </if>
                    </iterate>
                    <!--registering the shipping cost -->
                     <service-call name="mantle.order.OrderServices.create#OrderItem" in-map="[orderId: orderHeader.orderId,
                                                                                               orderPartSeqId: orderPart.orderPartSeqId,
                                                                                               itemTypeEnumId: 'ItemShipping',
                                                                                               itemDescription : carrierData.title,
                                                                                               quantity: 1,
                                                                                               unitAmount:carrierData.price]" out-map="context"/>
                    <if condition="orderHeader &amp;&amp; orderPart">
                        <!-- PAYMENT METHOD -->
                        <set field="creditCarddescription" from="paymentDetails.credit_card_company + ' ' + paymentDetails.credit_card_number"/>
                        <entity-find entity-name="mantle.account.method.PaymentMethod" list="paymentMethods">
                            <econdition field-name="ownerPartyId" from="partyId"/>
                            <econdition field-name="firstNameOnAccount"  from="customer.first_name"/>
                            <econdition field-name="paymentMethodTypeEnumId"  value="PmtCreditCard"/>
                            <econdition field-name="description" from="creditCarddescription"/>
                        </entity-find>
                        <!-- if the payment method exists, the system won't create another one -->
                        <if condition="!paymentMethods">
                            <service-call name="create#mantle.account.method.PaymentMethod" out-map="context" in-map="[ownerPartyId: partyId,
                                                                                                           paymentMethodTypeEnumId:'PmtCreditCard',
                                                                                                           firstNameOnAccount: customer.first_name,
                                                                                                           lastNameOnAccount:customer.last_name,
                                                                                                           description: creditCarddescription ]"/>
                        </if>
                        <set field="fromPartyId" from="orderPart.customerPartyId"/>
                        <entity-find entity-name="mantle.order.OrderPartParty" list="billList">
                            <econdition field-name="orderId"/><econdition field-name="orderPartSeqId"/>
                            <econdition field-name="roleTypeId" value="CustomerBillTo"/>
                        </entity-find>
                        <if condition="billToList"><set field="fromPartyId" from="billToList[0].partyId"/></if>
                        <service-call name="mantle.account.PaymentServices.create#Payment" out-map="context"
                                      in-map="context + [amount:(amount ?: orderPart.partTotal), amountUomId:orderHeader.currencyUomId,
                              statusId:'PmntDelivered', effectiveDate:ec.user.nowTimestamp, fromPartyId:fromPartyId, toPartyId:orderPart.vendorPartyId]"/>
                        <service-call name="mantle.order.OrderServices.set#OrderBillingShippingInfo" in-map="[orderId: orderHeader.orderId,
                                                                                                      paymentId: paymentId,
                                                                                                      paymentMethodId: paymentMethodId,
                                                                                                      carrierPartyId: moquiCarrierData.partyId,
                                                                                                      shipmentMethodEnumId: moquiShipmentMethod.shipmentMethodEnumId,
                                                                                                      shippingPostalContactMechId: postalContactMechId,
                                                                                                      shippingTelecomContactMechId: telecomContactMechId]" out-map="updatedPayment"/>
                        <service-call name="mantle.order.OrderServices.update#OrderStatus" out-map="context" in-map="[orderId: orderHeader.orderId,
                                                                                                              placedDate: ec.user.nowTimestamp,
                                                                                                              statusId: 'OrderPlaced']"/>
                        <service-call name="mantle.order.OrderServices.update#OrderStatus" out-map="context" in-map="[orderId: orderHeader.orderId,
                                                                                                              approvedDate: ec.user.nowTimestamp,
                                                                                                              statusId: 'OrderApproved']"/>
                        <service-call name="mantle.shopify.ApiServices.queue#GetCustomerAddressesSystemMessage" out-map="context"
                                      in-map="[postalMechId:postalContactMechId, partyId:partyId]"/>
                    </if>

            </if>
           
        </actions>
    </service>

    <service verb="queue" noun="GetCustomerAddressesSystemMessage">
        <in-parameters>
            <parameter name="postalMechId" required="true"/>
            <parameter name="partyId" required="true"/>
        </in-parameters>
        <actions>
            <entity-find-one entity-name="mantle.party.PartyIdentification" value-field="partyIdentification">
                <field-map field-name="partyId" />
                <field-map field-name="partyIdTypeEnumId" value="PtidShopify"/>
            </entity-find-one>
            <if condition="partyIdentification">
                <then>
                    <set field="messageText" from="groovy.json.JsonOutput.toJson([shopifyCustomerId:partyIdentification.idValue])"/>
                    <service-call name="org.moqui.impl.SystemMessageServices.queue#SystemMessage" out-map="context"
                                  in-map="[systemMessageTypeId:'ShopifyGetCustomerAddressesMessage', messageText:messageText, sentPartyId:partyId, sentContactMechId:postalMechId, docSubType:'getAddresses']"/>
                </then>
                <else>
                    <message type="warning">The customer ${partyId} does not have shopify id (idValue) in PartyIdentification entity</message>
                </else>
            </if>
        </actions>
    </service>

    <service verb="send" noun="GetCustomerAddressesSystemMessage">
        <implements service="org.moqui.impl.SystemMessageServices.send#SystemMessage"/>
        <in-parameters>
            <parameter name="systemMessageId" required="true"/>
        </in-parameters>
        <actions>
            <service-call name="mantle.shopify.ApiServices.send#SystemMessageRest"
                          in-map="[systemMessageId: systemMessageId]"
                          out-map="context"/>
            <entity-find-one entity-name="mantle.party.PartyIdentification" value-field="partyIdentification">
                <field-map field-name="partyId" from="systemMessage.sentPartyId"/>
                <field-map field-name="partyIdTypeEnumId" value="PtidShopify"/>
            </entity-find-one>
            <entity-find-one entity-name="mantle.party.contact.PostalAddress" value-field="postalAddress">
                <field-map field-name="contactMechId" from="systemMessage.sentContactMechId" />
            </entity-find-one>
            <set field="shopifyAddress" from="response.addresses.find{it.address1.equals(postalAddress?.address1 ?: '') &amp;&amp; it.address2.equals(postalAddress?.address2 ?: '')}"/>
            <if condition="shopifyAddress">
                <service-call name="update#mantle.party.contact.PostalAddress" out-map="context" in-map="postalAddress + [shopifyAddressId:shopifyAddress.id, shopifyDefaultAddress: shopifyAddress.default]"/>
            </if>
        </actions>
    </service>

    <service verb="queue" noun="SetInventorySystemMessage" authenticate="anonymous-all">
        <description>Service to update the quantity available in stock for a product</description>
        <in-parameters>
            <parameter name="productId" required="true"/>
        </in-parameters>
        <actions>

            <entity-find-one entity-name="mantle.product.ProductIdentification" value-field="shopifyInventoryItem">
                <field-map field-name="productId" from="productId"/>
                <field-map field-name="productIdTypeEnumId" value="PidtInventoryItemShopify"/>
            </entity-find-one>

            <if condition="!shopifyInventoryItem">
                <return error="true"
                        message="The product ${productId} must be a variant product"/>
            </if>
 
            <set field="inventoryItemId" from="shopifyInventoryItem.idValue"/>

            <!-- get the store id-->
            <service-call name="mantle.shopify.ShopifyServices.get#LocationAndStoreId" out-map="context"   in-map="[systemMessageTypeId:'ShopifySetInventoryMessage']"/>
            <entity-find-one entity-name="mantle.product.store.ProductStore" value-field="productStore"/>

            <!-- we need to find the available quantity for the current product -->
            <entity-find entity-name="mantle.product.asset.Asset" list="assetList">
                <econdition field-name="productId"/>
                <econdition field-name="facilityId"  from="productStore.inventoryFacilityId"/>
                <econdition field-name="assetTypeEnumId" value="AstTpInventory"/>
            </entity-find>

            <set field="avilableToPromiseList" from="assetList*.availableToPromiseTotal"/>
            <set field="available" from="avilableToPromiseList.findAll{it != null}.sum()?:0"/>

            <set field="messageText" from="groovy.json.JsonOutput.toJson([
                location_id:locationId,
                inventory_item_id:inventoryItemId,
                available:available
                ])"/>

            <service-call name="create#moqui.service.message.SystemMessage" in-map="[systemMessageTypeId:'ShopifySetInventoryMessage',
                                                                                             statusId:'SmsgProduced',
                                                                                             isOutgoing:'Y',
                                                                                             messageText:messageText,
                                                                                             docType:'updateInventoryLevel',
                                                                                             docSubType:'updateInventoryLevel',
                                                                                             initDate:ec.user.nowTimestamp
                                                                                             ]" out-map="context"/>
        </actions>
    </service>
        
    <service verb="send" noun="SetInventorySystemMessage">
        <implements service="org.moqui.impl.SystemMessageServices.send#SystemMessage"/>
        <in-parameters>
            <parameter name="systemMessageId" required="true"/>
        </in-parameters>
        <actions>
            <service-call name="mantle.shopify.ApiServices.send#SystemMessageRest" 
                          in-map="[systemMessageId: systemMessageId]"
                          out-map="context" />
        </actions>
    </service>
    <service verb="consume" noun="SetInventorySystemMessage">
        <actions>
            <entity-find entity-name="mantle.product.ProductInventoryUpdate" list="updatedProducts"/>
            <if condition="updatedProducts.size() &gt; 0">
                <iterate list="updatedProducts" entry="updatedProduct">
                    <service-call name="mantle.shopify.ApiServices.queue#SetInventorySystemMessage"
                                  in-map="[productId: updatedProduct.productId]"
                                  out-map="context"/>
                    <service-call name="delete#mantle.product.ProductInventoryUpdate"  in-map="[updateId:updatedProduct.updateId]" out-map="context"/>
                </iterate>
            </if>
        </actions>
    </service>

    <service verb="queue" noun="UpdateCustomerSystemMessage">
        <description>Service to updte customer</description>
        <in-parameters>
            <parameter name="partyId" required="true" />
        </in-parameters>
        <actions>

            <set field="customer" from="[:]"/>
            <set field="address" from="[:]"/>
            <set field="addressList" from="[]"/>

            <entity-find-one entity-name="mantle.party.Person" value-field="person">
                <field-map field-name="partyId" />
            </entity-find-one>

            <entity-find-one entity-name="mantle.party.Party" value-field="party">
                <field-map field-name="partyId" />
            </entity-find-one>
            <entity-find-one entity-name="mantle.party.PartyIdentification" value-field="partyIdentification">
                <field-map field-name="partyId" />
                <field-map field-name="partyIdTypeEnumId" value="PtidShopify"/>
            </entity-find-one>

            <if condition="!person">
                <return error="true" message="The customer ${partyId} does not exist" />
            </if>

            <if condition="!partyIdentification">
                <return error="true" message="The customer ${partyId} does not have shpopify indentification, contact the admin" />
            </if>

            <entity-find entity-name="mantle.party.contact.PartyContactMech" list="userEmailIdList">
                <econdition field-name="partyId" />
                <econdition field-name="contactMechPurposeId" value="EmailPrimary" />
                <date-filter/>
                <order-by field-name="fromDate"/>
            </entity-find>

            <set field="contactMechId" from="userEmailIdList.size()>0 ? userEmailIdList.first().contactMechId : null"/>
            <entity-find-one entity-name="mantle.party.contact.ContactMech" value-field="email">
                <field-map field-name="contactMechId"/>
            </entity-find-one>

            <entity-find entity-name="mantle.party.contact.PartyContactMech" list="userPhoneIdList">
                <econdition field-name="partyId" />
                <econdition field-name="contactMechPurposeId" value="PhonePrimary" />
                <date-filter/>
                <order-by field-name="fromDate"/>
            </entity-find>

            <set field="phoneContactMechId" from="userPhoneIdList.size() > 0 ? userPhoneIdList.first().contactMechId :  null"/>

            <entity-find-one entity-name="mantle.party.contact.TelecomNumber" value-field="userPhoneNumber">
                <field-map field-name="contactMechId" from="phoneContactMechId"/>
            </entity-find-one>

            <entity-find entity-name="mantle.party.contact.ContactMechPurpose" list="purposeAddressIdList">
                <econdition field-name="contactMechTypeEnumId" value="CmtPostalAddress"/>
            </entity-find>
            <set field="purposeAddressIds" from="purposeAddressIdList*.contactMechPurposeId"/>

            <entity-find entity-name="mantle.party.contact.PartyContactMech" list="customerAddressList">
                <econdition field-name="partyId" />
                <econdition field-name="contactMechPurposeId" operator="in" from="purposeAddressIds" />
                <date-filter/>
            </entity-find>

            <iterate list="customerAddressList" entry="customerAddressEntry">
                <entity-find-one entity-name="mantle.party.contact.PartyContactMechPostalAddress" value-field="customerAddress">
                    <field-map field-name="contactMechId" from="customerAddressEntry.contactMechId"/>
                </entity-find-one>

                <if condition="!customerAddress">
                    <log message="The party ${partyId} - ${person.firstName} ${person.lastName?:''} does not have register on postalAddress, contact the admin."/>
                    <continue/>
                </if>
                <set field="firstAndLasNameCustomerAddres" from="customerAddress?.toName ? customerAddress?.toName.split(' ').findAll { it != ''} : ''"/>
                <set field="firstNameAtAddress" from="firstAndLasNameCustomerAddres[0]"/>
                <set field="lastNameAtAddress" from="firstAndLasNameCustomerAddres.size() >=1 ? firstAndLasNameCustomerAddres[1] : ''"/>

                <entity-find-one entity-name="moqui.basic.Geo" value-field="geoContry">
                    <field-map field-name="geoId" from="customerAddress?.countryGeoId"/>
                </entity-find-one>

                <entity-find-one entity-name="mantle.party.contact.TelecomNumber" value-field="userAddressPhoneNumber">
                    <field-map field-name="contactMechId" from="customerAddress?.telecomContactMechId"/>
                </entity-find-one>

                <set field="addressPhone" from="getPhoneFormat(userAddressPhoneNumber)"/>
                <set field="address.id" from="customerAddress?.shopifyAddressId"/>
                <set field="address.customer_id" from="partyIdentification.idValue"/>
                <set field="address.first_name" from="firstNameAtAddress"/>
                <set field="address.last_name" from="lastNameAtAddress"/> 
                <set field="address.address1" from="customerAddress?.address1"/>
                <set field="address.address2" from="customerAddress?.address2"/>
                <set field="address.city" from="customerAddress?.city"/>
                <set field="address.province" from="customerAddress?.stateGeoName"/>
                <set field="address.country" from="geoContry?.geoName"/>
                <set field="address.zip" from="customerAddress?.postalCode"/>
                <set field="address.phone" from="addressPhone"/>
                <set field="address.province_code" from="customerAddress?.stateGeoCodeAlpha2"/>
                <set field="address.country_code" from="geoContry?.geoCodeAlpha2"/>
                <set field="address.country_name" from="geoContry?.geoName"/>
                <script>
                    addressList.add(address)
                    address = [:]
                </script> 
            </iterate>

            <if condition="!partyIdentification">
                <message type="warning">The customer ${partyId} does not have shopifyId, please contact the admin</message>
            </if>
            <if condition="!customerAddress?.shopifyAddressId">
                <message type="warning">The customer ${partyId} does not have shopifyAddressId, please contact the admin</message>
            </if>

            <script>
                def getPhoneFormat(phoneNumber){
                    def phone = null
                    if (phoneNumber?.countryCode) {
                            phone = phoneNumber.countryCode
                    }
                    if (phoneNumber?.areaCode) {
                            phone = phone + phoneNumber.areaCode
                    }
                    if (phoneNumber?.contactNumber) {
                            phone = phone + phoneNumber.contactNumber.replace('-','')
                    }
                    if (phone) {
                            phone = '+' +phone
                    }
                    return phone
                }
            </script>
            <set field="phone" from="getPhoneFormat(userPhoneNumber)"/>
            <set field="customer.id" from="partyIdentification.idValue"/>
            <set field="customer.email" from="email?.infoString"/>
            <set field="customer.first_name" from="person?.firstName"/>
            <set field="customer.last_name" from="person?.lastName"/>
            <set field="customer.phone" from="phone"/>
            <set field="customer.addresses" from="addressList"/>
            <set field="messageText" from="groovy.json.JsonOutput.toJson([customer:customer])"/>

            <service-call name="create#moqui.service.message.SystemMessage" in-map="[systemMessageTypeId:'ShopifyUpdateCustomerMessage',
                                                                                             statusId:'SmsgProduced',
                                                                                             isOutgoing:'Y',
                                                                                             messageText:messageText,
                                                                                             docType:'json',
                                                                                             docSubType:'putCustomer',
                                                                                             docSubControl:'putCustomer',
                                                                                             docControl:customer.id,
                                                                                             initDate:ec.user.nowTimestamp
                                                                                             ]" out-map="context"/>
        </actions>
    </service>

    <service verb="send" noun="UpdateCustomerSystemMessage">
        <implements service="org.moqui.impl.SystemMessageServices.send#SystemMessage"/>
        <in-parameters>
            <parameter name="systemMessageId" required="true"/>
        </in-parameters>
        <actions>
            <service-call name="mantle.shopify.ApiServices.send#SystemMessageRest" 
                          in-map="[systemMessageId: systemMessageId]"
                          out-map="context" />

            <set field="addresses" from="response.customer.addresses"/>
            <iterate list="addresses" entry="customerAddress">
                <entity-find-one entity-name="mantle.party.contact.PostalAddress" value-field="postalAddres" for-update="true">
                    <field-map field-name="toName" from="customerAddress.name"/>
                    <field-map field-name="address1" from="customerAddress.address1"/>
                    <field-map field-name="address2" from="customerAddress.address2"/>
                    <field-map field-name="city" from="customerAddress.city"/>
                    <field-map field-name="postalCode" from="customerAddress.zip"/>
                </entity-find-one>
                <if condition="postalAddres">
                    <set field="postalAddres.shopifyDefaultAddress" from="customerAddress.default"/>
                    <set field="postalAddres.shopifyAddressId" from="customerAddress.id"/>
                    <entity-update value-field="postalAddres"/>
                </if>
            </iterate>
        </actions>
    </service>

    <service verb="queue" noun="CancelAndCalculateRefundOrderSystemMessage" authenticate="anonymous-all">
        <description>Service to cancel and calculate the refund</description>
        <in-parameters>
            <parameter name="orderId" required="true" />
        </in-parameters>
        <actions>

            <entity-find-one entity-name="mantle.order.OrderHeader" value-field="order"/>

            <!-- only shopify orders are processed -->
            <if condition="order.salesChannelEnumId == 'ScShopify'">
                <set field="refund_line_items" from="[]"/>
                <set field="refund" from="[:]"/>
                <set field="shipping" from="[:]"/>
                <entity-find entity-name="mantle.order.OrderItem" list="orderItems">
                    <econdition field-name="orderId"  from="order.orderId"/>
                    <econdition field-name="itemTypeEnumId"  value="ItemProduct"/>
                    <econdition field-name="quantityCancelled"   operator="greater" from="0.0"/>
                </entity-find>

                <iterate list="orderItems" entry="item">
                    <script>
                        def items = [:]
                        items.line_item_id = item.externalItemSeqId
                        items.quantity = item.quantityCancelled
                        items.restock_type = 'cancel'
                        refund_line_items.add(items)
                    </script>
                </iterate>

                <set field="externalId" from="order.externalId" />
                <set field="currencyUomId" from="order.currencyUomId" />
                <set field="shipping.full_refund" value="true"/>
                <set field="refund.shipping" from="shipping"/>
                <set field="refund.currency" from="currencyUomId"/>
                <set field="refund.refund_line_items" from="refund_line_items"/>
                <set field="refund.orderStatus" from="order.statusId" />
                <set field="refund.orderId" from="externalId" />
                <set field="messageText" from="groovy.json.JsonOutput.toJson([refund:refund])"/>

                <!-- The service to calculate refund order is called only if exist items to cancel -->
                <if condition="refund_line_items">
                    <service-call name="mantle.shopify.ShopifyServices.validate#AlreadyCreatedSystemMessage" in-map="[shopifyOrderId:order.externalId, 
                                                                                                                        systemMessageTypeId:'ShopifyCalculateRefundMessage',
                                                                                                                        statusId:'SmsgProduced']" out-map="context"/>

                    <if condition="systemMessageAlreadyExist">
                        <return error="true" message="ERROR: a System Message already exist for this order ${orderId}"/>
                    </if>

                    <service-call name="create#moqui.service.message.SystemMessage" in-map="[systemMessageTypeId:'ShopifyCalculateRefundMessage',
                                                                                                statusId:'SmsgProduced',
                                                                                                isOutgoing:'Y',
                                                                                                messageText:messageText,
                                                                                                docType:'json',
                                                                                                docSubType:'cancelOrder',
                                                                                                docSubControl:'calculateRefund',
                                                                                                shopifyOrderId:externalId,
                                                                                                shopifyDisplayOrderId:order.displayId,
                                                                                                orderId:order.orderId,
                                                                                                initDate:ec.user.nowTimestamp
                                                                                                ]" out-map="context"/>
                </if>
            </if>
        </actions>
    </service>

    <service verb="send" noun="CancelAndCalculateRefundOrderSystemMessage">
        <implements service="org.moqui.impl.SystemMessageServices.send#SystemMessage"/>
        <in-parameters>
            <parameter name="systemMessageId" required="true"/>
        </in-parameters>
        <actions>
            <service-call name="mantle.shopify.ApiServices.send#SystemMessageRest" 
                          in-map="[systemMessageId: systemMessageId]"
                          out-map="context" />

            <script>
                import groovy.json.JsonSlurper 
                def jsonSlurper = new JsonSlurper()
                def order = jsonSlurper.parseText(systemMessage.messageText)
            </script>
            
            <set field="orderStatus" from="order.refund.orderStatus"/>
            <set field="orderId" from="order.refund.orderId"/>
            <set field="refund" from="[:]"/>
            <set field="shipping" from="[:]"/>
            <set field="refund_line_items" from="[]"/>
            <set field="transactions" from="[]"/>

            <iterate list="response.refund.refund_line_items" entry="item">
                <script>
                    def items = [:]
                    items.line_item_id = item.line_item_id
                    items.quantity = item.quantity
                    items.restock_type = item.restock_type
                    items.location_id =  item.location_id
                    refund_line_items.add(items)
                </script>
            </iterate>

            <iterate list="response.refund.transactions" entry="transaction">
                <script>
                    def tx = [:]
                    tx.parent_id = transaction.parent_id
                    tx.amount = transaction.amount
                    tx.kind = 'refund'
                    tx.gateway =  transaction.gateway
                    transactions.add(tx)
                </script>
            </iterate>

            <set field="shipping.full_refund" value="true"/>
            <set field="refund.currency" from="response.refund.currency"/>
            <set field="refund.shipping" from="shipping"/>
            <set field="refund.refund_line_items" from="refund_line_items"/>
            <set field="refund.transactions" from="transactions"/>
            <set field="externalId" from="orderId" />

            <set field="messageText" from="groovy.json.JsonOutput.toJson([refund:refund])"/>

            <if condition="orderStatus == 'OrderCompleted'" > 
                <then>
                    <!--if the order has some fulfilled item, it's necessary to refund the cancel item -->
                    <service-call name="org.moqui.impl.SystemMessageServices.queue#SystemMessage" out-map="context"
                    in-map="[systemMessageTypeId:'ShopifyCancelOrderMessage',
                             messageText:messageText,
                             docSubControl:'createRefund',
                             orderId:systemMessage.orderId,
                             shopifyOrderId:externalId]"/>
                </then>
                <else>
                    <!-- if the order was cancelled by the user, its necessary to cancel all it's items -->
                    <service-call name="org.moqui.impl.SystemMessageServices.queue#SystemMessage" out-map="context"
                    in-map="[systemMessageTypeId:'ShopifyCancelOrderMessage',
                             messageText:messageText,
                             docSubControl:'cancelOrder',
                             orderId:systemMessage.orderId,
                             shopifyOrderId:externalId]"/>
                </else>
            </if>

            <entity-find-one entity-name="mantle.order.OrderHeader" value-field="orderToUpdate" for-update="true">
                <field-map  field-name="externalId" from="externalId" />
            </entity-find-one>
            <set field="orderToUpdate.shopifyOrderStatusId"  value="OrderCancelled"/>
            <entity-update value-field="orderToUpdate"/>
        </actions>
    </service>

    <service verb="queue" noun="CreateFulfillmentSystemMessage" authenticate="anonymous-all">
        <description>Service to register a fulfillment for a order</description>
        <in-parameters>
            <parameter name="shipmentId" required="true" />
        </in-parameters>
        <actions>

            <entity-find-one entity-name="mantle.shipment.Shipment" value-field="shipment"/>

            <set field="line_items" from="[]"/>
            <set field="fulfillment" from="[:]"/>

            <if condition="!shipment.statusId  in ['ShipShipped','ShipDelivered']">
                <return error="true" message="ERROR:The shipment ${shipment.shipmentId} must be in status Shipped or Delivered for registering a fulfillment "/>
            </if>

            <!-- get the store id -->
            <service-call name="mantle.shopify.ShopifyServices.get#LocationAndStoreId" out-map="context"   in-map="[systemMessageTypeId:'ShopifyCreateFulfillmentMessage']"/>
            <service-call name="mantle.shipment.ShipmentInfoServices.get#ShipmentDisplayInfo" in-map="[shipmentId:shipment.shipmentId]" out-map="context"/>
            <set field="orderId" from="shipmentItemSourceList.first().orderId"/>
            <entity-find-one entity-name="mantle.order.OrderHeader" value-field="orderHeader">
                <field-map field-name="orderId" />
            </entity-find-one>

            <!-- only shopify orders are processed -->
            <if condition="orderHeader.salesChannelEnumId == 'ScShopify'">
                <entity-find entity-name="mantle.order.OrderItem" list="orderItems">
                    <econdition field-name="orderId"  from="orderId"/>
                    <econdition field-name="itemTypeEnumId"  value="ItemProduct"/>
                    <econdition field-name="quantity"   operator="greater" from="0.0"/>
                </entity-find>
            
                <iterate list="allShipmentPackageContentList" entry="item">
                    <script>
                        def productTemp = orderItems.find{it.productId == item.productId}
                        def items = [:]
                        items.id = productTemp.externalItemSeqId
                        items.quantity = item.quantity
                        line_items.add(items)
                    </script>
                </iterate>

                <entity-find-one entity-name="mantle.party.PartyIdentification" value-field="partyIdentification">
                    <field-map field-name="partyId"  from="curCarrierDetail?.partyId"/>
                    <field-map field-name="partyIdTypeEnumId" value="PtidShopify"/>
                </entity-find-one>
            
                <set field="externalId" from="orderHeader.externalId" />
                <set field="fulfillment.location_id" from="locationId" />
                <set field="fulfillment.tracking_number" from="packageRouteSegList[0]?.trackingCode" />
                <set field="fulfillment.tracking_company" from="partyIdentification?.idValue" />
                <set field="fulfillment.line_items" from="line_items" />
                <set field="messageText" from="groovy.json.JsonOutput.toJson([fulfillment:fulfillment])"/>

                <!-- The service to create fulfillment is called only if there are shipped items  -->
                <if condition="line_items">
                    <service-call name="mantle.shopify.ShopifyServices.validate#AlreadyCreatedSystemMessage" in-map="[shopifyOrderId:externalId,
                                                                                                                      systemMessageTypeId:'ShopifyCreateFulfillmentMessage',
                                                                                                                      statusId:'SmsgProduced']" out-map="context"/>
                    <if condition="systemMessageAlreadyExist">
                        <return error="true" message="ERROR: a System Message already exist for the shipment ${shipmentId}"/>
                    </if>
                    <service-call name="create#moqui.service.message.SystemMessage" in-map="[systemMessageTypeId:'ShopifyCreateFulfillmentMessage',
                                                                                                statusId:'SmsgProduced', 
                                                                                                isOutgoing:'Y', 
                                                                                                messageText:messageText, 
                                                                                                docType:'json',
                                                                                                docSubType:'createFulfillment',
                                                                                                docSubControl:'createFulfillment',
                                                                                                shopifyOrderId:externalId,
                                                                                                shopifyDisplayOrderId:orderHeader.displayId,
                                                                                                orderId:orderHeader.orderId,
                                                                                                sentShipmentId:shipment.shipmentId,
                                                                                                initDate:ec.user.nowTimestamp
                                                                                                ]" out-map="context"/>
                </if>
            </if>
        </actions>
    </service>
    
    <service verb="send" noun="CreateFulfillmentSystemMessage">
        <implements service="org.moqui.impl.SystemMessageServices.send#SystemMessage"/>
        <in-parameters>
            <parameter name="systemMessageId" required="true"/>
        </in-parameters>
        <actions>
            <service-call name="mantle.shopify.ApiServices.send#SystemMessageRest" 
                          in-map="[systemMessageId: systemMessageId]"
                          out-map="context" />

            <entity-find-one entity-name="mantle.shipment.Shipment" value-field="shipment" for-update="true">
                <field-map field-name="shipmentId" from="systemMessage.sentShipmentId"/>
            </entity-find-one>

            <set field="shipment.shopifyShipmentStatusId"  value="ShipShipped"/>
            <entity-update value-field="shipment"/>
        </actions>
    </service>

    <service verb="send" noun="CancelOrderSystemMessage">
        <implements service="org.moqui.impl.SystemMessageServices.send#SystemMessage"/>
        <in-parameters>
            <parameter name="systemMessageId" required="true"/>
        </in-parameters>
        <actions>
            <service-call name="mantle.shopify.ApiServices.send#SystemMessageRest" 
                          in-map="[systemMessageId: systemMessageId]"
                          out-map="context" />
        </actions>
    </service>

    <service verb="send" noun="CreateRefundSystemMessage">
        <implements service="org.moqui.impl.SystemMessageServices.send#SystemMessage"/>
        <in-parameters>
            <parameter name="systemMessageId" required="true"/>
        </in-parameters>
        <actions>
            <service-call name="mantle.shopify.ApiServices.send#SystemMessageRest" 
                          in-map="[systemMessageId: systemMessageId]"
                          out-map="context" />
        </actions>
    </service>
</services>
