<?xml version="1.0" encoding="UTF-8"?>
<services xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="http://moqui.org/xsd/service-definition-2.1.xsd">

	<!-- 
        Endpoint to pull down products from Shopify.

        https://{store_name}.myshopify.com/admin/api/2023-04/products.json?limit={limit}&since_id={product_id}
    -->
    <service verb="download" noun="ShopifyProducts">
        <in-parameters>
            <parameter name="systemMessageRemoteId" required="true"/>
            <parameter name="limit" default-value="250"/>
        </in-parameters>
        <actions>
            <script>import groovy.json.JsonSlurper</script>
            <entity-find-one entity-name="moqui.service.message.SystemMessageRemote" value-field="remote">
                <field-map field-name="systemMessageTypeId" value="ShopifySystemMessageType"/>
                <field-map field-name="systemMessageRemoteId"/></entity-find-one>

            <if condition="!remote"><return error="true" message="No Remote of type 'ShopifySystemMessageType' found for ID ${systemMessageRemoteId}"/></if>

            <!-- see if we have called this before and what was the last order found on previous message -->
            <entity-find entity-name="moqui.service.message.SystemMessage" limit="1" list="prevMessages">
                <econdition field-name="systemMessageTypeId" value='ShopifySystemMessageType'/>
                <econdition field-name="systemMessageRemoteId"/>
                <econdition field-name="docType" value="products"/>
                <select-field field-name="systemMessageTypeId,systemMessageRemoteId,initDate,docVersion"/>
                <order-by field-name="-initDate"/>
            </entity-find>
            <set field="updated_at_min" from="prevMessages ? prevMessages.first().docVersion : null"/>

            <!-- The natural ordering of the 'products' on the Shopify endpoint appear to be 'created_at'
            This is problematic, because if you update a previously imported product in shopify, it wont re-appear in the list.
            the query string param order=updated_at is undocumented but works, we want the oldest products first -->
            <script><![CDATA[
                //String url = ec.resource.expand(remote.sendUrl, "", [store_name:remote.username, resource:"products"]) + "?limit=${limit}&order=updated_at+asc";
                String url = "https://${remote.username}.myshopify.com/admin/api/2023-01/products.json?limit=${limit}&order=updated_at+asc";

                if (updated_at_min != null) {
                    url += "&updated_at_min=${updated_at_min}";
                }

                org.moqui.util.RestClient.RestResponse restResponse = ec.service.rest().method("GET")
                    .addHeader("X-Shopify-Access-Token", remote.password).uri(url).call();

                if (restResponse.statusCode != 200) {
                    ec.message.addError("Shopify Productss API Response ${restResponse.statusCode} ${restResponse.reasonPhrase}: ${restResponse.text()} for url: ${url}")
                    return
                }

                ec.logger.info("url: ${url}")

                Map messageMap = new JsonSlurper().parseText(restResponse.text());
            ]]></script>

            <if condition="messageMap.products">
                <set field="dateFormat" from="java.time.format.DateTimeFormatter.ISO_OFFSET_DATE_TIME"/>
                <set field="updatedAt" from="java.time.OffsetDateTime.parse(messageMap.products.last().updated_at, dateFormat)"/>
                <set field="updatedAtStr" from="updatedAt.plusSeconds(1).format(dateFormat)"/>
                <service-call name="create#moqui.service.message.SystemMessage" out-map="context"
                                in-map="[systemMessageTypeId:'ShopifySystemMessageType', systemMessageRemoteId:systemMessageRemoteId,
                                messageText:restResponse.text(), docType:'json', docType:'products', docVersion:updatedAtStr,
                                isOutgoing:'N', initDate:ec.user.nowTimestamp, statusId:'SmsgReceived']"/>
            </if>
        </actions>
    </service>

    <!-- 
        Takes the list of Products and splits it into a separate child SystemMessage for each product
        This was necessary for storing the lastProductId in the docControl of the parent message.
    -->
    <service verb="consume" noun="ProductListSystemMessage">
        <implements service="org.moqui.impl.SystemMessageServices.consume#SystemMessage"/>
        <actions>
            <entity-find-one entity-name="moqui.service.message.SystemMessage" value-field="systemMessage"/>

            <entity-find-one entity-name="moqui.service.message.SystemMessageRemote" value-field="remote">
                <field-map field-name="systemMessageTypeId" value="ShopifySystemMessageType"/>
                <field-map field-name="systemMessageRemoteId" from="systemMessage.systemMessageRemoteId"/>
            </entity-find-one>

            <entity-find-one entity-name="mantle.product.store.ProductStore" value-field="productStore">
                <field-map field-name="productStoreId" from="remote.productStoreId"/></entity-find-one>
            <if condition="!productStore"><return error="true" message="No ProductStore found for ID ${remote.productStoreId}"/></if>


            <set field="messageMap" from="new groovy.json.JsonSlurper().parseText(systemMessage.messageText)"/>
            <iterate list="messageMap.products" entry="product">
                <service-call name="mantle.shopify.ShopifyProductServices.store#ShopifyProduct"
                    in-map="[productStore:productStore, product:product]"/>
            </iterate>
        </actions>
    </service>

   <!--
        Consumes the system message for a single product 
        Creates the basic data for a product and its variants. 
        Does not handle digital products yet.
    -->
    <service verb="store" noun="ShopifyProduct">
        <in-parameters>
            <parameter name="product" required="true" type="Map"/>
            <parameter name="productStore" required="true" type="Map"/>
        </in-parameters>
        <actions>
            <set field="ownerPartyId" from="productStore.organizationPartyId ?: '_NA_'"/>

            <entity-find-one entity-name="mantle.product.ProductIdentification" value-field="existingShopifyId">
                <field-map field-name="idValue" from="product.id"/>
                <field-map field-name="productIdTypeEnumId" value="PidtShopify"/>
            </entity-find-one>
            <if condition="existingShopifyId"><then>
                <set field="productId" from="existingShopifyId.productId"/>
                <service-call name="update#mantle.product.Product" in-map="[
                    productId:productId, productName:product.title,  description:product.body_html]" out-map="context"/>
            </then><else>
                <service-call name="create#mantle.product.Product" in-map="[
                    productTypeEnumId:'PtVirtual', ownerPartyId:ownerPartyId, productName:product.title,  description:product.body_html]" out-map="context"/>
                <service-call name="create#mantle.product.ProductIdentification" in-map="[
                    productId:productId, productIdTypeEnumId:'PidtShopify', idValue:product.id]" out-map="context"/>
            </else></if>

            <set field="mapOptionToFeature" from="[:]"/>
            <iterate list="product.options" entry="option">
                <!-- the value option.id and option.position apply at the 'values' level in moqui -->
                <entity-find-one entity-name="moqui.basic.Enumeration" value-field="featureType">
                    <field-map field-name="enumTypeId" value="ProductFeatureType"/>
                    <field-map field-name="description" from="option.name"/>
                </entity-find-one>
                <if condition="!featureType">
                    <return error="true" message="No featureType found with description: ${option.name} for product ${product.id}"/>
                </if>
                <iterate list="option.values" entry="value">
                    <!-- create the product features on the virtual product as 'Selectable' -->
                    <service-call name="mantle.product.ProductServices.create#ProductFeature" in-map="[
                        productId:productId, productFeatureTypeEnumId:featureType.enumId, applTypeEnumId:'PfatSelectable', ownerPartyId:ownerPartyId, description:value, idCode:option.id]" out-map="context"/>

                    <set field="mapOptionToFeature[value]" from="productFeatureId"/> 
                </iterate>
            </iterate>

            <entity-find entity-name="mantle.product.ProductContent" list="contentList">
                <econdition field-name="productContentTypeEnumId" value="PcntImageUrlDetail"/>
                <econdition field-name="productId" from="productId" /><date-filter/>
            </entity-find>
            <iterate list="product.images" entry="image">
                <!-- we look for content with the same url on the product, and if not, create -->
                <set field="content" from="contentList.find({it.contentLocation == image.src})" />
                <if condition="!content">
                    <service-call name="create#mantle.product.ProductContent" in-map="[
                        productId:productId, productContentTypeEnumId:'PcntImageUrlDetail', contentLocation:image.src]"/>
                </if>
            </iterate>

            <entity-find-one entity-name="mantle.product.Product" value-field="product" />
            <iterate list="product.variants" entry="variant">
                <!-- the variants from shopify come with ambiguous names -->
                <set field="variant.title" from="product.title + ' - ' + variant.title"/>

                <service-call name="mantle.shopify.ShopifyProductServices.store#ShopifyVariant" 
                    in-map="[productStoreId:productStore.productStoreId, ownerPartyId:ownerPartyId, inventoryFacilityId:productStore.inventoryFacilityId, productId:productId, mapOptionToFeature:mapOptionToFeature, variant:variant]"/>
            </iterate>
        </actions>
    </service>
 
    <service verb="store" noun="ShopifyVariant">
        <in-parameters>
            <parameter name="productStoreId" />
            <parameter name="ownerPartyId"/>
            <parameter name="inventoryFacilityId"/>
            <parameter name="productId" />
            <parameter name="mapOptionToFeature" type="Map"/>
            <parameter name="variant" type="Map"/>
        </in-parameters>
        <actions>
            <entity-find-one entity-name="mantle.product.ProductIdentification" value-field="existingShopifyId">
                <field-map field-name="idValue" from="variant.id"/>
                <field-map field-name="productIdTypeEnumId" value="PidtShopify"/>
            </entity-find-one>
            <if condition="existingShopifyId"><then>
                <set field="variantProductId" from="existingShopifyId.productId"/>
                <service-call name="update#mantle.product.Product" in-map="[productId:variantProductId, productName:variant.title]"/>
            </then><else>
                <service-call name="create#mantle.product.Product" in-map="[
                    productName:variant.title, productTypeEnumId:'PtAsset', assetTypeEnumId:'AstTpInventory', ownerPartyId:ownerPartyId, ownerPartyId:ownerPartyId]" out-map="variantContext"/>
                <set field="variantProductId" from="variantContext.productId"/>

                <service-call name="create#mantle.product.ProductAssoc" in-map="[
                    productId:productId, toProductId:variantProductId, productAssocTypeEnumId:'PatVariant', fromDate:ec.user.nowTimestamp]"/>

                <service-call name="create#mantle.product.ProductIdentification" in-map="[
                    productId:variantProductId, productIdTypeEnumId:'PidtShopify', idValue:variant.id]"/>

                <service-call name="create#mantle.product.ProductIdentification" out-map="context" in-map="[
                    productId:variantProductId, productIdTypeEnumId:'PidtInventoryItemShopify', idValue:variant.inventory_item_id]"/>
            </else></if>

            <!-- The variant.option1 needs to have been previously listed/created with the virtual product -->
            <set field="productFeatureId" from="mapOptionToFeature[variant.option1]"/>

            <service-call name="mantle.product.ProductServices.apply#ProductFeatures"
                in-map="[productId:variantProductId, productFeatureIdList:[productFeatureId], applTypeEnumId:'PfatStandard',
                    fromDate:ec.user.nowTimestamp, sequenceNum:variant.position]"/>

            <if condition="variant.option2">
                <set field="productFeatureId" from="mapOptionToFeature[variant.option2]"/>
                <service-call name="mantle.product.ProductServices.apply#ProductFeatures"
                    in-map="[productId:variantProductId, productFeatureIdList:[productFeatureId], applTypeEnumId:'PfatStandard',
                    fromDate:ec.user.nowTimestamp, sequenceNum:variant.position]"/>
            </if>

            <if condition="variant.option3">
                <set field="productFeatureId" from="mapOptionToFeature[variant.option3]"/>
                <service-call name="mantle.product.ProductServices.apply#ProductFeatures"
                    in-map="[productId:variantProductId, productFeatureIdList:[productFeatureId], applTypeEnumId:'PfatStandard',
                    fromDate:ec.user.nowTimestamp, sequenceNum:variant.position]"/>
            </if>

            <if condition="variant.weight &amp;&amp; variant.weight_unit">
                <service-call name="mantle.shopify.ShopifyProductServices.create#ShopifyWeight" in-map="[
                    productId:variantProductId, weight:variant.weight, unit:variant.weight_unit]"/>
            </if>

            <if condition="variant.price">
                <service-call name="mantle.shopify.ShopifyProductServices.create#ShopifyPrice" in-map="[
                    productStoreId:productStoreId, productId:variantProductId, amount:variant.price]"/>
            </if>

            <!-- optional property on the shopify object -->
            <iterate list="variant.presentment_prices" entry="price">
                <service-call name="mantle.shopify.ShopifyProductServices.create#ShopifyPrice" in-map="[
                    productStoreId:productStoreId, productId:variantProductId, currency:price.currency, amount:price.amount]"/>
            </iterate>

            <!-- If inventory is managed by Moqui, we would not process this value from Shopify -->
            <if condition="variant.inventory_management == 'shopify'">
                <!--service-call name="mantle.product.AssetServices.record#PhysicalInventoryQuantity" out-map="assetOut"
                        in-map="[productId:variantProductId, facilityId:inventoryFacilityId, 
                            ownerPartyId:ownerPartyId, statusId:'AstAvailable', quantity:variant.inventory_quantity]" async="true"/-->
            </if>
        </actions>
    </service>

    <service verb="create" noun="ShopifyWeight">
        <in-parameters>
            <parameter name="productId" required="true"/>
            <parameter name="weight" required="true"/>
            <parameter name="unit" required="true"/>
        </in-parameters>
        <actions>
            <entity-find-one entity-name="moqui.basic.Uom" value-field="weightUom">
                <field-map field-name="uomTypeEnumId" value="UT_WEIGHT_MEASURE"/>
                <field-map field-name="abbreviation" from="unit"/>
            </entity-find-one>

            <entity-find-one entity-name="mantle.product.ProductDimension" value-field="dimension">
                <field-map field-name="dimensionTypeId" value="ShippingWeight"/>
                <field-map field-name="valueUomId" from="weightUom.uomId"/>
            </entity-find-one>

            <if condition="dimension">
                <return /><!-- weight found, do nothing -->
            </if>

            <service-call name="create#mantle.product.ProductDimension" in-map="[
                productId:productId, dimensionTypeId:'ShippingWeight', valueUomId:weightUom.uomId, value:weight]"/>
        </actions>
    </service>

    <service verb="create" noun="ShopifyPrice">
        <in-parameters>
            <parameter name="productStoreId" required="true"/>
            <parameter name="productId" required="true"/>
            <parameter name="currency" default-value="USD"/>
            <parameter name="amount" type="BigDecimal" required="true"/>
        </in-parameters>
        <actions>
            <entity-find-one entity-name="moqui.basic.Uom" value-field="priceUom">
                <field-map field-name="uomTypeEnumId" value="UT_CURRENCY_MEASURE"/>
                <field-map field-name="abbreviation" from="currency"/>
            </entity-find-one>

            <entity-find entity-name="mantle.product.ProductPrice" list="existingPrices" for-update="true">
                <econdition field-name="priceTypeEnumId" value="PptCurrent"/>
                <econdition field-name="pricePurposeEnumId" value="PppPurchase"/>
                <econdition field-name="productStoreId" from="productStoreId"/>
                <econdition field-name="priceUomId" from="priceUom.uomId"/>
                <date-filter />
            </entity-find>

            <if condition="existingPrices">
                <iterate list="existingPrices" entry="existingPrice">
                    <if condition="existingPrice.price == amount">
                        <return /><!-- identical price found, do nothing -->
                    </if>
                    <!-- different price found, expire this, create new -->
                    <set field="existingPrice.thruDate" from="ec.user.nowTimestamp"/>
                    <entity-update value-field="existingPrice"/>
                </iterate>
            </if>

            <service-call name="create#mantle.product.ProductPrice" in-map="[
                priceTypeEnumId:'PptCurrent', pricePurposeEnumId:'PppPurchase', productStoreId:productStoreId, productId:productId, priceUomId:priceUom.uomId, price:amount, fromDate:ec.user.nowTimestamp]"/>
        </actions>
    </service>

    <!-- TODO perhaps check the modified date accross key entities and only upload if this is newer than previous execution -->
    <service verb="upload" noun="MoquiStoreProducts">
        <in-parameters>
            <parameter name="systemMessageRemoteId" required="true"/>
        </in-parameters>
        <out-parameters>
            <parameter name="productIdList"/>
        </out-parameters>
        <actions>
            <entity-find-one entity-name="moqui.service.message.SystemMessageRemote" value-field="remote"/>
            <if condition="!remote"><return error="true" message="No Remote found for ID ${systemMessageRemoteId}"/></if>

            <!-- get all the categories for this store -->
            <service-call name="mantle.shopify.ShopifyProductServices.get#ProductStoreCategories"
                    in-map="[productStoreId:remote.productStoreId]" out-map="context"/>

            <!-- get all the memberships to the categories -->
            <entity-find entity-name="mantle.product.category.ProductCategoryMember" list="pcmList"><date-filter />
                <econdition field-name="productCategoryId" operator="in" from="productCategoryIdList"/></entity-find>

            <!-- get a unique list of productIds based on those memberships -->
            <set field="productIdList" from="pcmList.productId.unique( false )"/>

            <iterate list="productIdList" entry="productId">
                <service-call name="mantle.shopify.ShopifyProductServices.upload#MoquiProduct"
                    in-map="[systemMessageRemoteId:systemMessageRemoteId, productId:productId]"/>
            </iterate>
        </actions>
    </service>

    <service verb="upload" noun="MoquiProduct">
        <in-parameters>
            <parameter name="systemMessageRemoteId" required="true"/>
            <parameter name="productId" required="true"/>
        </in-parameters>
        <actions>
            <entity-find-one entity-name="moqui.service.message.SystemMessageRemote" value-field="remote"/>

            <entity-find-one entity-name="mantle.product.ProductIdentification" value-field="shopifyIdentification">
                <field-map field-name="productIdTypeEnumId" value="PidtShopify"/>
                <field-map field-name="productId"/></entity-find-one>

            <service-call name="mantle.shopify.ShopifyProductServices.get#ProductData" out-map="context"
                in-map="[productId:productId, productStoreId:remote.productStoreId]"/>

            <if condition="shopifyIdentification">
                <set field="productData.id" from="shopifyIdentification.idValue"/>
            </if>

            <set field="apiResponse" value="[:]"/>
            <script><![CDATA[
                String method = shopifyIdentification ? 'PUT' : 'POST';
                String endpoint = shopifyIdentification ? "products/${shopifyIdentification.idValue}" : "products";
                String url = "https://${remote.username}.myshopify.com/admin/api/2023-01/${endpoint}.json";
                String json = groovy.json.JsonOutput.toJson([product: productData]);

                org.moqui.util.RestClient.RestResponse restResponse = ec.service.rest().method(method)
                    .addHeader("Content-Type", "application/json").jsonObject(json)
                    .addHeader("X-Shopify-Access-Token", remote.password).uri(url).call();

                if (restResponse.statusCode != 201 && restResponse.statusCode != 200) {
                    ec.message.addError("Shopify Products API Error ${restResponse.statusCode} ${restResponse.reasonPhrase}: ${restResponse.text()} ${json}")
                    return;
                }
                apiResponse = new groovy.json.JsonSlurper().parseText(restResponse.text());
            ]]></script>
            <set field="shopifyVariants" from="apiResponse.product.variants"/>

            <if condition="!shopifyIdentification">
                <service-call name="create#mantle.product.ProductIdentification" out-map="context" 
                    in-map="[productId:productId, productIdTypeEnumId:'PidtShopify', idValue: apiResponse.product.id]"/>

                <!-- if the moqui product had no variants, then we use the inventory item from the auto-created shopify variant -->
                <if condition="!productData.variants &amp;&amp; shopifyVariants">
                    <service-call name="create#mantle.product.ProductIdentification" out-map="context" 
                        in-map="[productId:productId, productIdTypeEnumId:'PidtInventoryItemShopify', idValue:shopifyVariants[0].inventory_item_id]"/>
                </if>
            </if>

            <if condition="shopifyVariants">
                <iterate list="shopifyVariants" entry="variant">
                    <!-- the only way to match the response to the request is via the options -->
                    <set field="moquiProductId" from="productData.variants.find({it.option1 == variant.option1 
                                                                      &amp;&amp; it.option2 == variant.option2 
                                                                      &amp;&amp; it.option3 == variant.option3})?.metafields[0].value"/>
                    <if condition="!moquiProductId">
                        <continue/><!-- this should never happen, the moquiProductId is set inside get#ProductData -->
                    </if>

                    <entity-find-one entity-name="mantle.product.ProductIdentification" value-field="variantIdentification">
                        <field-map field-name="productIdTypeEnumId" value="PidtShopify"/>
                        <field-map field-name="productId"/></entity-find-one>
                    <if condition="variantIdentification">
                        <!-- identification already created for this variant, ignoring -->
                        <continue/>
                    </if>

                    <service-call name="create#mantle.product.ProductIdentification" out-map="context" 
                        in-map="[productId:moquiProductId, productIdTypeEnumId:'PidtShopify', idValue:variant.id]"/>
                    <service-call name="create#mantle.product.ProductIdentification" out-map="context" 
                        in-map="[productId:moquiProductId, productIdTypeEnumId:'PidtInventoryItemShopify', idValue:variant.inventory_item_id]"/>
                </iterate>
            </if>
        </actions>
    </service>

    <service verb="get" noun="ProductData">
        <in-parameters>
            <parameter name="productId" required="true"/>
            <parameter name="productStoreId" required="true"/>
        </in-parameters>
        <out-parameters>
            <parameter name="productData"/>
        </out-parameters>
        <actions>
            <entity-find-one entity-name="mantle.product.Product" value-field="product"/>
            <entity-find-one entity-name="mantle.product.store.ProductStore" value-field="productStore"/>
            <entity-find entity-name="mantle.product.store.ProductStoreSetting" list="imageUrlSettingList">
                <econdition field-name="settingTypeEnumId" value="PsstProductImageUrl"/>
                <econdition field-name="productStoreId"/><date-filter/></entity-find>

            <if condition="!imageUrlSettingList">
                <return error="true" message="Product Store ${productStoreId} has no PsstProductImageUrl configured, cannot upload images"/>
            </if>

            <entity-find entity-name="mantle.product.ProductContent" list="imageContentList">
                <econdition field-name="productContentTypeEnumId" operator="in" value="PcntImageDetail,PcntImageLarge,PcntImageMedium,PcntImageOriginal"/>
                <econdition field-name="productId"/><date-filter/></entity-find>

            <set field="images" from="[]"/>
            <iterate list="imageContentList" entry="content">
                <set field="settings" from="[storeDomain:productStore.storeDomain, productContentId:content.productContentId, productId:productId]"/>
                <set field="imageUrl" from="ec.resource.expand(imageUrlSettingList.first().settingValue, null, settings, false)"/>
                <set field="images" from="images.plus([src: imageUrl])"/>
            </iterate>

            <set field="prodVariants" from="[]"/>
            <set field="prodOptions" from="[]"/>
            <if condition="product.productTypeEnumId == 'PtVirtual'">
                <!-- Get all the products associated to the parent product /-->
                <entity-find entity-name="mantle.product.ProductAssoc" list="assocList">
                    <econdition field-name="productId"/>
                    <econdition field-name="fromDate" operator="is-not-null"/>
                    <econdition field-name="thruDate" operator="is-null"/>
                </entity-find>


                <iterate list="assocList" entry="assoc">
                    <!-- Each product associated has at least one feature so we get all possible features /-->
                    <entity-find entity-name="mantle.product.feature.ProductAndFeatureAndFeatureAppl" list="featureList">
                        <econdition field-name="productId" from="assoc.toProductId"/>
                        <econdition field-name="applTypeEnumId" value="PfatDistinguishing"/>
                        <date-filter/>
                        <order-by field-name="sequenceNum"/>
                    </entity-find>

                    <if condition="featureList.size() == 0">
                        <set field="error" value="true"/>
                        <message type="warning">The associated product ${assoc.toProductId}  must have at least one Features, add one in Features section </message>
                        <return/>
                    </if>

                    <service-call name="mantle.product.PriceServices.get#ProductPrice" out-map="priceSet" in-map="[productId:assoc.toProductId]"/>

                    <entity-find-one entity-name="mantle.product.ProductIdentification" value-field="prodUPC">
                        <field-map field-name="productId" from="assoc.toProductId"/>
                        <field-map field-name="productIdTypeEnumId" value="PidtUpca"/>
                    </entity-find-one>

                    <entity-find-one entity-name="mantle.product.ProductDimension" value-field="productDimension">
                        <field-map field-name="productId" from="assoc.toProductId"/>
                    </entity-find-one>

                    <if condition="productDimension">
                        <entity-find-one entity-name="moqui.basic.Uom" value-field="uom">
                            <field-map field-name="uomId" from="productDimension.valueUomId"/>
                        </entity-find-one>
                    </if>

                    <entity-find-one entity-name="mantle.product.ProductIdentification" value-field="prodSKU">
                        <field-map field-name="productId" from="assoc.toProductId"/>
                        <field-map field-name="productIdTypeEnumId" value="PidtSku"/>
                    </entity-find-one>

                    <service-call name="mantle.product.AssetServices.get#AvailableInventory" out-map="assetOut"
                        in-map="[productId:productId, productStoreId:productStoreId]"/>
                   
                    <script><![CDATA[
                        /**
                            The featureList is the list of all the features that an assoc has,
                            if it's only one feature, we don't need to make the combinations
                            if it the product has more than one feature we have to make the combinations
                            in order to follow the shopify format.

                            NOTE: Shopify supports products that has at most 3 features.
                        **/

                        variant = [:]
                        variant.option1 = featureList[0]?.productFeatureDescription
                        variant.option2 = featureList[1]?.productFeatureDescription
                        variant.option3 = featureList[2]?.productFeatureDescription
                        variant.name = variant.option1 +
                            (variant.option2 ? '/' + variant.option2 : '') + 
                            (variant.option3 ? '/' + variant.option3 : '');
                        variant.position = assoc.sequenceNum
                        variant.price = priceSet.price
                        variant.inventory_management = 'shopify'
                        variant.inventory_quantity = availableToPromiseTotal
                        variant.barcode = prodUPC?.idValue
                        variant.weight = productDimension?.value
                        variant.weight_unit = uom?.abbreviation
                        variant.sku = prodSKU?.idValue
                        variant.metafields = [[namespace:'global', type:'single_line_text_field', key:'moquiproductid', value:assoc.toProductId]]

                        prodVariants.add(variant)
                    ]]>
                    </script>
                </iterate>

                <!-- get all the selectable features for the virtual product -->
                <entity-find entity-name="mantle.product.feature.ProductAndFeatureAndFeatureAppl" list="prodFeatureList">
                    <econdition field-name="productId" from="productId"/>
                    <econdition field-name="applTypeEnumId" value="PfatSelectable"/>
                    <date-filter/>
                    <order-by field-name="sequenceNum"/>
                </entity-find>
                <!-- iterate all the unique selectable feature types for this product-->
                <iterate list="featureList.productFeatureTypeEnumId.unique( false )" entry="enumId">
                    <entity-find-one entity-name="moqui.basic.Enumeration" value-field="featureTypeEnum"/>
                    <!-- find all the variations for this feature, and get a simple list of descriptions, e.g ['Black', 'Blue', 'Green'] -->
                    <set field="featureDescList" from="prodFeatureList.findAll{it.productFeatureTypeEnumId == enumId}.productFeatureDescription"/>
                    <!-- create the shopify object with name and values, e.g {name:'Color', values:['Black', 'Blue', 'Green']} -->
                    <set field="prodOptions" from="prodOptions.plus([name:featureTypeEnum.description, values:featureDescList])"/>
                </iterate>
            </if>
            <set field="productData" from="[
                title: product.productName,
                inventory_management: 'shopify',
                metafields: [[namespace:'global', type:'single_line_text_field', key:'moquiproductid', value:productId]]
            ]"/>
            <if condition="product.description">
                <set field="productData.body_html" from="product.description"/>
            </if>
            <if condition="images">
                <set field="productData.images" from="images"/>
            </if>
            <if condition="prodVariants">
                <set field="productData.variants" from="prodVariants"/>
            </if>
            <if condition="prodOptions">
                <set field="productData.options" from="prodOptions"/>
            </if>
        </actions>
    </service>

    <!-- 
        Endpoint to pull down products from Shopify.

        https://{store_name}.myshopify.com/admin/api/2023-04/custom_collections.json?limit={limit}
    -->
    <service verb="download" noun="ShopifyCollections">
        <in-parameters>
            <parameter name="systemMessageRemoteId" required="true"/>
            <parameter name="limit" default-value="250"/>
        </in-parameters>
        <out-parameters>
            <parameter name="productCategoryIdList"/>
        </out-parameters>
        <actions>
            <script>import groovy.json.JsonSlurper</script>
            <entity-find-one entity-name="moqui.service.message.SystemMessageRemote" value-field="remote" />
            <if condition="!remote"><return error="true" message="No Remote of type 'ShopifySystemMessageType' found for ID ${systemMessageRemoteId}"/></if>
            <entity-find-related-one relationship-name="mantle.product.store.ProductStore" value-field="remote" to-value-field="productStore"/>
            <if condition="!productStore"><return error="true" message="No ProductStore configured for remote ID ${systemMessageRemoteId}"/></if>

            <!-- get the browse root for this store, this is needed to store the new categories under -->
            <entity-find entity-name="mantle.product.store.ProductStoreCategory" list="pscList">
                <econdition field-name="storeCategoryTypeEnumId" value="PsctBrowseRoot"/>
                <econdition field-name="productStoreId" from="remote.productStoreId"/><date-filter /></entity-find>
            <if condition="!pscList"><return error="true" message="No Browse Root Category found for Store ID ${productStoreId}"/></if>
            <set field="browseRootCategoryid" from="pscList.first().productCategoryId"/>

            <set field="apiResponse" from="[:]"/>
            <script><![CDATA[
                String collectionsUrl = "https://${remote.username}.myshopify.com/admin/api/2023-01/custom_collections.json?limit=${limit}";

                org.moqui.util.RestClient.RestResponse collectionsRestResponse = ec.service.rest().method("GET")
                    .addHeader("X-Shopify-Access-Token", remote.password).uri(collectionsUrl).call();

                if (collectionsRestResponse.statusCode != 200) {
                    String apiError = "${collectionsRestResponse.statusCode} ${collectionsRestResponse.reasonPhrase}: ${collectionsRestResponse.text()}"
                } else {
                    apiResponse = new groovy.json.JsonSlurper().parseText(collectionsRestResponse.text());
                }
            ]]></script>
            <if condition="apiError">
                <return error="true" message="Shopify Collections API Error ${apiError}"/>
            </if>
            <set field="productCategoryIdList" from="[]"/>
            <iterate list="apiResponse.custom_collections" entry="collection">
                <entity-find-one entity-name="mantle.product.category.ProductCategory" value-field="category">
                    <field-map field-name="pseudoId" from="collection.id"/></entity-find-one>

                <if condition="category"><then>
                    <set field="productCategoryId" from="category.productCategoryId"/>
                    <set field="category.categoryName" from="collection.title"/>
                    <set field="category.description" from="collection.body_html"/>
                    <entity-update value-field="category"/>
                </then><else>
                    <service-call name="create#mantle.product.category.ProductCategory" out-map="context"
                        in-map="[productCategoryTypeEnumId:'PctCatalog', pseudoId:collection.id, categoryName:collection.title, description:collection.body_html, ownerPartyId:productStore.organizationPartyId]"/>

                    <service-call name="create#mantle.product.category.ProductCategoryRollup" out-map="context"
                        in-map="[productCategoryId:productCategoryId, parentProductCategoryId:browseRootCategoryid, fromDate:collection.published_at]"/>
                </else></if>

                <set field="apiResponse" value="[:]"/>
                <script><![CDATA[
                    //String collectsUrl = ec.resource.expand(remote.sendUrl, "", [store_name:remote.username, resource:"collects"]) + "?collection_id=${collection.id}";
                    String collectsUrl = "https://${remote.username}.myshopify.com/admin/api/2023-01/collects.json?collection_id=${collection.id}";

                    org.moqui.util.RestClient.RestResponse collectsRestResponse = ec.service.rest().method("GET")
                        .addHeader("X-Shopify-Access-Token", remote.password).uri(collectsUrl).call()

                    if (collectsRestResponse.statusCode != 200) {
                        apiError = "${collectsRestResponse.statusCode} ${collectsRestResponse.reasonPhrase}: ${collectsRestResponse.text()}"
                    } else {
                        apiResponse = new groovy.json.JsonSlurper().parseText(collectsRestResponse.text());
                    }
                ]]></script>
                <if condition="apiError">
                    <return error="Shopify Collecs API Error ${apiError}"/>
                </if>

                <iterate list="apiResponse.collects" entry="collect">
                    <!-- get the moquiId id of this shopifyId -->
                    <entity-find-one entity-name="mantle.product.ProductIdentification" value-field="shopifyId">
                        <field-map field-name="productIdTypeEnumId" value="PidtShopify"/>
                        <field-map field-name="idValue" from="collect.product_id"/></entity-find-one>

                    <if condition="!shopifyId">
                        <return error="true" message="The Shopify product_id: ${collect.product_id} is not linked with a moqui product, please download the products first calling download#ShopifyProducts" />
                    </if>
                    <entity-find entity-name="mantle.product.category.ProductCategoryMember" list="pcmList">
                        <econdition field-name="productId" from="shopifyId.productId"/>
                        <econdition field-name="productCategoryId"/><date-filter/></entity-find>

                    <if condition="!pcmList">
                        <service-call name="create#mantle.product.category.ProductCategoryMember" out-map="context"
                            in-map="[productCategoryId:productCategoryId, productId:shopifyId.productId, 
                            fromDate:collection.created_at ?: ec.user.nowTimestamp]"/>
                    </if>
                </iterate>
                <set field="productCategoryIdList" from="productCategoryIdList.plus(productCategoryId)"/>
            </iterate>
        </actions>
    </service>

    <service verb="upload" noun="MoquiStoreCategories">
        <in-parameters>
            <parameter name="systemMessageRemoteId" required="true"/>
        </in-parameters>
        <out-parameters>
            <parameter name="productCategoryIdList"/>
        </out-parameters>
        <actions>
            <entity-find-one entity-name="moqui.service.message.SystemMessageRemote" value-field="remote" />
            <if condition="!remote"><return error="true" message="No Remote found for ID ${systemMessageRemoteId}"/></if>

            <!-- get the browse root for this store -->
            <entity-find entity-name="mantle.product.store.ProductStoreCategory" list="pscList">
                <econdition field-name="storeCategoryTypeEnumId" value="PsctBrowseRoot"/>
                <econdition field-name="productStoreId" from="remote.productStoreId"/><date-filter /></entity-find>
            <if condition="!pscList"><return error="true" message="No Browse Root Category found for Store ID ${productStoreId}"/></if>

            <!-- We get all the categories under the browse root recursively -->
            <service-call name="mantle.shopify.ShopifyProductServices.populate#CategoriesRecursive" out-map="context"
                in-map="[parentProductCategoryId:pscList.first().productCategoryId]"/>

            <iterate list="productCategoryIdList" entry="productCategoryId">
                <service-call name="mantle.shopify.ShopifyProductServices.upload#MoquiCategory"
                    in-map="[systemMessageRemoteId:systemMessageRemoteId, productCategoryId:productCategoryId]"/>
            </iterate>
        </actions>
    </service>

    <service verb="upload" noun="MoquiCategory">
        <in-parameters>
            <parameter name="systemMessageRemoteId" required="true"/>
            <parameter name="productCategoryId" required="true"/>
        </in-parameters>
        <actions>
            <entity-find-one entity-name="moqui.service.message.SystemMessageRemote" value-field="remote"/>
            <entity-find-one entity-name="mantle.product.category.ProductCategory" value-field="category" for-update="true"/>

            <set field="apiResponse" value="[:]"/>

            <!-- get all the products assigned to these categories -->
            <entity-find entity-name="mantle.product.category.ProductCategoryMember" list="pcmList">
                <econdition field-name="productCategoryId"/><date-filter /></entity-find>

            <!-- get the shopiify ids of those products -->
            <entity-find entity-name="mantle.product.ProductIdentification" list="pidList">
                <econdition field-name="productId" operator="in" from="pcmList.productId"/>
                <econdition field-name="productIdTypeEnumId" value="PidtShopify"/>
            </entity-find>

            <set field="existingCollects" from="[]"/>

            <!-- if the pseudoId is not the same as productCategoryId, we think it was populated with custom_collection.id from Shopify -->
            <if condition="category.pseudoId != category.productCategoryId">
                <script><![CDATA[
                    //String url = ec.resource.expand(remote.sendUrl, '', [resource:'collects']) + '?collection_id=' + category.pseudoId;
                    String url = "https://${remote.username}.myshopify.com/admin/api/2023-01/collects.json?collection_id=" + category.pseudoId;

                    org.moqui.util.RestClient.RestResponse restResponse = ec.service.rest().method('GET')
                        .addHeader("X-Shopify-Access-Token", remote.password).uri(url).call();

                    if (restResponse.statusCode != 201) {
                        ec.message.addError("Shopify custom_collection API Error ${restResponse.statusCode} ${restResponse.reasonPhrase}: ${restResponse.text()}, possibly the pseudoId for Product Category ${productCategoryId} was not Shopify custom_collection.id");
                        return;
                    }
                    apiResponse = new groovy.json.JsonSlurper().parseText(restResponse.text());
                ]]></script>
                <set field="existingCollects" from="apiResponse.collects.product_id"/>
            </if>

            <set field="collects" from="[]"/>
            <iterate list="pidList" entry="pid">
                <if condition="existingCollects.find({it.toString() == pid.idValue})">
                    <log message="product_id: ${pid.idValue} already exists on collection, skipping"/>
                    <continue/>
                </if>
                <set field="collects" from="collects.plus([product_id:pid.idValue])"/>
            </iterate>
            
            <set field="custom_collection" from="[:]"/>
            <set field="custom_collection.title" from="category.categoryName"/>
            <set field="custom_collection.collects" from="collects"/>
            
            <script><![CDATA[
                String method = category.pseudoId == category.productCategoryId ? 'POST' : 'PUT';
                String endpoint = category.pseudoId == category.productCategoryId ? 'custom_collections' : 'custom_collections/'+category.pseudoId;
                String url = "https://${remote.username}.myshopify.com/admin/api/2023-01/${endpoint}.json";

                org.moqui.util.RestClient.RestResponse restResponse = ec.service.rest().method(method)
                    .addHeader("Content-Type", "application/json").addHeader("X-Shopify-Access-Token", remote.password)
                    .jsonObject(groovy.json.JsonOutput.toJson([custom_collection: custom_collection]))
                    .uri(url).call();

                if (restResponse.statusCode != 201) {
                    ec.message.addError("Shopify custom_collection API Error ${restResponse.statusCode} ${restResponse.reasonPhrase}: ${restResponse.text()}");
                    return;
                }
                apiResponse = new groovy.json.JsonSlurper().parseText(restResponse.text());
            ]]></script>
            <if condition="!apiResponse.custom_collection.id">
                <return error="No custom_collection ID on API Response ${restResponse.text()}"/>
            </if>
            <set field="category.pseudoId" from="apiResponse.custom_collection.id"/>
            <entity-update value-field="category"/>
        </actions>
    </service>

    <service verb="get" noun="ProductStoreCategories">
        <in-parameters>
            <parameter name="productStoreId" required="true"/>
            <parameter name="storeCategoryTypeEnumId"/>
        </in-parameters>
        <out-parameters>
            <parameter name="productCategoryIdList"/>
        </out-parameters>
        <actions>
            <!-- Get just the browse root for this store -->
            <entity-find entity-name="mantle.product.store.ProductStoreCategory" list="pscList">
                <econdition field-name="storeCategoryTypeEnumId" operator="in" ignore-if-empty="true"/>
                <econdition field-name="productStoreId"/><date-filter /></entity-find>

            <set field="productCategoryIdList" from="[]"/>
            <iterate list="pscList" entry="psc">
                <set field="productCategoryIdList" from="productCategoryIdList.plus(psc.productCategoryId)"/>
                <service-call name="mantle.shopify.ShopifyProductServices.populate#CategoriesRecursive" out-map="context"
                    in-map="[parentProductCategoryId:psc.productCategoryId, productCategoryIdList:productCategoryIdList]"/>
            </iterate>
        </actions>
    </service>

    <service verb="populate" noun="CategoriesRecursive">
        <in-parameters>
            <parameter name="parentProductCategoryId" required="true"/>
            <parameter name="productCategoryIdList" type="List"/>
        </in-parameters>
        <out-parameters>
            <parameter name="productCategoryIdList"/>
        </out-parameters>
        <actions>
            <!-- get all the child category rollups -->
            <entity-find entity-name="mantle.product.category.ProductCategoryRollup" list="rollupList">
                <econdition field-name="parentProductCategoryId"/><date-filter /></entity-find>

            <iterate list="rollupList" entry="rollup">
                <!-- check if this category has already been included in the productCategoryIdList List -->
                <if condition="productCategoryIdList.find({it == rollup.productCategoryId})">
                     <log message="Category ID ${rollup.productCategoryId} previously added, skipping"/>
                     <continue/>
                </if>
                <set field="productCategoryIdList" from="productCategoryIdList ? productCategoryIdList.plus(rollup.productCategoryId) : [rollup.productCategoryId]"/>

                <service-call name="mantle.shopify.ShopifyProductServices.populate#CategoriesRecursive" out-map="context"
                    in-map="[parentProductCategoryId:rollup.productCategoryId, productCategoryIdList:productCategoryIdList]"/>
            </iterate>
        </actions>
    </service>


    <service verb="queue" noun="ProductInventory">
        <in-parameters>
            <parameter name="productId" required="true"/>
            <parameter name="facilityId" required="true"/>
        </in-parameters>
        <out-parameters>
            <parameter name="productCategoryIdList"/>
        </out-parameters>
        <actions>
            <entity-find-one entity-name="mantle.product.ProductIdentification" value-field="productPidt">
                <field-map field-name="productIdTypeEnumId" value="PidtInventoryItemShopify"/>
                <field-map field-name="productId"/></entity-find-one>

            <if condition="!productPidt">
                <log message="Product ID: ${productId} not identified in Shopify, ignoring"/>
                <return/>
            </if>

            <!-- get the product stores that relate to this facility -->
            <entity-find entity-name="mantle.product.store.ProductStoreFacility" list="stores">
                <econdition field-name="facilityId"/><date-filter /></entity-find>

            <!-- check if this product is managed by any Shopify remotes -->
            <entity-find entity-name="moqui.service.message.SystemMessageRemote" list="remotes">
                <econdition field-name="productStoreId" operator="in" from="stores.productStoreId"/>
                <econdition field-name="systemMessageTypeId" value="ShopifySystemMessageType"/></entity-find>

            <if condition="!remotes">
                <log message="Facility ID: ${facilityId} not managed by any Shopfiy remotes, ignoring"/>
                <return/>
            </if>

            <service-call name="mantle.product.AssetServices.get#AvailableInventory" in-map="context" out-map="context"/>
            <entity-find-one entity-name="mantle.shopify.ProductInventoryQueue" value-field="queuedInventory" for-update="true"/>

            <if condition="!queuedInventory"><then>
                <service-call name="create#mantle.shopify.ProductInventoryQueue" 
                    in-map="context + [availableToPromise:availableToPromiseTotal, inventoryItemId:productPidt.idValue]"/>
            </then><else-if condition="queuedInventory.availableToPromise != availableToPromiseTotal">
                <set field="queuedInventory.availableToPromise" from="availableToPromiseTotal"/>
                <entity-update value-field="queuedInventory"/>
            </else-if></if>
        </actions>
    </service>

    <service verb="upload" noun="ProductInventoryQueue">
        <in-parameters>
            <parameter name="systemMessageRemoteId" required="true"/>
            <parameter name="limit" type="Integer" default-value="250">The limit per facility connected to the store on the Remote</parameter>
        </in-parameters>
        <actions>
            <entity-find-one entity-name="moqui.service.message.SystemMessageRemote" value-field="remote">
                <field-map field-name="systemMessageTypeId" value="ShopifySystemMessageType"/>
                <field-map field-name="systemMessageRemoteId"/>
            </entity-find-one>

            <entity-find entity-name="mantle.product.store.ProductStoreFacility" list="storeFacilities">
                <econdition field-name="productStoreId" from="remote.productStoreId"/><date-filter /></entity-find>

            <log message="storeFacilities: ${storeFacilities}"/>

            <iterate list="storeFacilities" entry="storeFacility">
                <entity-find-one entity-name="mantle.facility.Facility" value-field="facility">
                    <field-map field-name="facilityId" from="storeFacility.facilityId"/></entity-find-one>

                <if condition="!facility.externalId"><return error="true" message="Shopify location_id not stored on facility.externalId for ${storeFacility.facilityId} consider running configure#FacilityFromShopifyLocation"/></if>

                <!-- get all the queued inventory updates for this facility -->
                <entity-find entity-name="mantle.shopify.ProductInventoryQueue" limit="limit" list="productInventoryQueue">
                    <econdition field-name="facilityId" from="storeFacility.facilityId"/></entity-find>

                <iterate list="productInventoryQueue" entry="productInventory">
                    <set field="inventory" from="[
                        location_id:facility.externalId,
                        inventory_item_id:productInventory.inventoryItemId,
                        available:productInventory.availableToPromise
                    ]"/>

                    <log message="inventory: ${inventory}"/>

                    <script><![CDATA[
                        String url = "https://${remote.username}.myshopify.com/admin/api/2023-01/inventory_levels/set.json";

                        org.moqui.util.RestClient.RestResponse restResponse = ec.service.rest().method('POST')
                            .addHeader("X-Shopify-Access-Token", remote.password).addHeader("Content-Type", "application/json")
                            .jsonObject(groovy.json.JsonOutput.toJson(inventory)).uri(url).call();

                        if (restResponse.statusCode != 200) {
                            ec.message.addError("Shopify inventory_levels/set API Error ${restResponse.statusCode} ${restResponse.reasonPhrase}: ${restResponse.text()} url:${url}");
                        }
                    ]]></script>
                    <entity-delete value-field="productInventory"/>
                </iterate>
            </iterate>
        </actions>
    </service>
</services>