<?xml version="1.0" encoding="UTF-8"?>
<services xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="http://moqui.org/xsd/service-definition-2.1.xsd">

	<!-- 
        Endpoint to pull down products from Shopify.

        https://{store_name}.myshopify.com/admin/api/2023-04/products.json?limit={limit}&since_id={product_id}
    -->
    <service verb="download" noun="ShopifyProducts">
        <in-parameters>
            <parameter name="systemMessageRemoteId" required="true"/>
            <parameter name="limit" default-value="250"/>
        </in-parameters>
        <actions>
            <script>import groovy.json.JsonSlurper</script>
            <entity-find-one entity-name="moqui.service.message.SystemMessageRemote" value-field="systemMessageRemote">
                <field-map field-name="systemMessageTypeId" value="ShopifySystemMessageType"/>
                <field-map field-name="systemMessageRemoteId"/>
            </entity-find-one>

            <if condition="!systemMessageRemote"><return error="true" message="No Remote of type 'ShopifySystemMessageType' found for ID ${systemMessageRemoteId}"/></if>

            <!-- see if we have called this before and what was the last order found on previous message -->
            <entity-find entity-name="moqui.service.message.SystemMessage" limit="1" list="prevMessages">
                <econdition field-name="systemMessageTypeId" value='ShopifySystemMessageType'/>
                <econdition field-name="systemMessageRemoteId"/>
                <econdition field-name="docType" value="products"/>
                <select-field field-name="systemMessageTypeId,systemMessageRemoteId,initDate,docVersion"/>
                <order-by field-name="-initDate"/>
            </entity-find>
            <set field="updated_at_min" from="prevMessages ? prevMessages.first().docVersion : null"/>

            <log message="prevMessages: ${prevMessages}" />

            <!-- The natural ordering of the 'products' on the Shopify endpoint appear to be 'created_at'
            This is problematic, because if you update a previously imported product in shopify, it wont re-appear in the list.
            the query string param order=updated_at is undocumented but works, we want the oldest products first -->
            <script><![CDATA[
                String url = ec.resource.expand(systemMessageRemote.sendUrl, "", [resource:"products"]) + "?limit=${limit}&order=updated_at+asc";
                if (updated_at_min != null) {
                    url += "&updated_at_min=${updated_at_min}";
                }

                org.moqui.util.RestClient.RestResponse restResponse = ec.service.rest().method("GET")
                    .basicAuth(systemMessageRemote.username, systemMessageRemote.password).uri(url).call();

                if (restResponse.statusCode != 200) {
                    ec.message.addError("Shopify Productss API Response ${restResponse.statusCode} ${restResponse.reasonPhrase}: ${restResponse.text()} for url: ${url}")
                    return
                }

                ec.logger.info("url: ${url}")

                Map messageMap = new JsonSlurper().parseText(restResponse.text());
            ]]></script>

            <if condition="messageMap.products">
                <log message="products found"/>
                <set field="dateFormat" from="java.time.format.DateTimeFormatter.ISO_OFFSET_DATE_TIME"/>
                <set field="updatedAt" from="java.time.OffsetDateTime.parse(messageMap.products.last().updated_at, dateFormat)"/>
                <set field="updatedAtStr" from="updatedAt.plusSeconds(1).format(dateFormat)"/>
                <service-call name="create#moqui.service.message.SystemMessage" out-map="context"
                                in-map="[systemMessageTypeId:'ShopifySystemMessageType', systemMessageRemoteId:systemMessageRemoteId,
                                messageText:restResponse.text(), docType:'json', docType:'products', docVersion:updatedAtStr,
                                isOutgoing:'N', initDate:ec.user.nowTimestamp, statusId:'SmsgReceived']"/>
            </if>
        </actions>
    </service>

    <!-- 
        Takes the list of Products and splits it into a separate child SystemMessage for each product
        This was necessary for storing the lastProductId in the docControl of the parent message.
    -->
    <service verb="consume" noun="ProductListSystemMessage">
        <implements service="org.moqui.impl.SystemMessageServices.consume#SystemMessage"/>
        <actions>
            <entity-find-one entity-name="moqui.service.message.SystemMessage" value-field="systemMessage"/>

            <entity-find-one entity-name="moqui.service.message.SystemMessageRemote" value-field="remote">
                <field-map field-name="systemMessageTypeId" value="ShopifySystemMessageType"/>
                <field-map field-name="systemMessageRemoteId" from="systemMessage.systemMessageRemoteId"/>
            </entity-find-one>

            <entity-find-one entity-name="mantle.product.store.ProductStore" value-field="productStore">
                <field-map field-name="productStoreId" from="remote.productStoreId"/></entity-find-one>
            <if condition="!productStore"><return error="true" message="No ProductStore found for ID ${remote.productStoreId}"/></if>


            <set field="messageMap" from="new groovy.json.JsonSlurper().parseText(systemMessage.messageText)"/>
            <iterate list="messageMap.products" entry="product">
                <service-call name="mantle.shopify.ShopifyProductServices.store#ShopifyProduct"
                    in-map="[productStore:productStore, product:product]"/>
            </iterate>
        </actions>
    </service>

   <!--
        Consumes the system message for a single product 
        Creates the basic data for a product and its variants. 
        Does not handle digital products yet.
    -->
    <service verb="store" noun="ShopifyProduct">
        <in-parameters>
            <parameter name="product" required="true" type="Map"/>
            <parameter name="productStore" required="true" type="Map"/>
        </in-parameters>
        <actions>
            <set field="ownerPartyId" from="productStore.organizationPartyId ?: '_NA_'"/>

            <entity-find-one entity-name="mantle.product.ProductIdentification" value-field="existingShopifyId">
                <field-map field-name="idValue" from="product.id" />
                <field-map field-name="productIdTypeEnumId" value="PidtShopify"/>
            </entity-find-one>
            <if condition="existingShopifyId"><then>
                <set field="productId" from="existingShopifyId.productId"/>
                <service-call name="update#mantle.product.Product" in-map="[
                    productId:productId, productName:product.title,  description:product.body_html]" out-map="context"/>
            </then><else>
                <service-call name="create#mantle.product.Product" in-map="[
                    productTypeEnumId:'PtVirtual', ownerPartyId:ownerPartyId, productName:product.title,  description:product.body_html]" out-map="context"/>
                <service-call name="create#mantle.product.ProductIdentification" in-map="[
                    productId:productId, productIdTypeEnumId:'PidtShopify', idValue:product.id]" out-map="context"/>
            </else></if>

            <set field="mapOptionToFeature" from="[:]"/>
            <iterate list="product.options" entry="option">
                <!-- the value option.id and option.position apply at the 'values' level in moqui -->
                <entity-find-one entity-name="moqui.basic.Enumeration" value-field="featureType">
                    <field-map field-name="enumTypeId" value="ProductFeatureType"/>
                    <field-map field-name="description" from="option.name"/>
                </entity-find-one>
                <if condition="!featureType">
                    <return error="true" message="No featureType found with description: ${option.name}"/>
                </if>
                <iterate list="option.values" entry="value">
                    <!-- create the product features on the virtual product as 'Selectable' -->
                    <service-call name="mantle.product.ProductServices.create#ProductFeature" in-map="[
                        productId:productId, productFeatureTypeEnumId:featureType.enumId, applTypeEnumId:'PfatSelectable', ownerPartyId:ownerPartyId, description:value, idCode:option.id]" out-map="context"/>

                    <set field="mapOptionToFeature[value]" from="productFeatureId"/> 
                </iterate>
            </iterate>

            <entity-find entity-name="mantle.product.ProductContent" list="contentList">
                <econdition field-name="productContentTypeEnumId" value="PcntImageUrlDetail"/>
                <econdition field-name="productId" from="productId" /><date-filter/>
            </entity-find>
            <iterate list="product.images" entry="image">
                <!-- we look for content with the same url on the product, and if not, create -->
                <set field="content" from="contentList.find({it.contentLocation == image.src})" />
                <if condition="!content">
                    <service-call name="create#mantle.product.ProductContent" in-map="[
                        productId:productId, productContentTypeEnumId:'PcntImageUrlDetail', contentLocation:image.src]"/>
                </if>
            </iterate>

            <entity-find-one entity-name="mantle.product.Product" value-field="product" />
            <iterate list="product.variants" entry="variant">
                <!-- the variants from shopify come with ambiguous names -->
                <set field="variant.title" from="product.title + ' - ' + variant.title"/>

                <service-call name="mantle.shopify.ShopifyProductServices.store#ShopifyVariant" 
                    in-map="[productStoreId:productStore.productStoreId, ownerPartyId:ownerPartyId, inventoryFacilityId:productStore.inventoryFacilityId, productId:productId, mapOptionToFeature:mapOptionToFeature, variant:variant]"/>
            </iterate>
        </actions>
    </service>
 
    <service verb="store" noun="ShopifyVariant">
        <in-parameters>
            <parameter name="productStoreId" />
            <parameter name="ownerPartyId"/>
            <parameter name="inventoryFacilityId"/>
            <parameter name="productId" />
            <parameter name="mapOptionToFeature" type="Map"/>
            <parameter name="variant" type="Map"/>
        </in-parameters>
        <actions>
            <entity-find-one entity-name="mantle.product.ProductIdentification" value-field="existingShopifyId">
                <field-map field-name="idValue" from="variant.id" />
                <field-map field-name="productIdTypeEnumId" value="PidtShopify"/>
            </entity-find-one>
            <if condition="existingShopifyId"><then>
                <set field="variantProductId" from="existingShopifyId.productId"/>
                <service-call name="update#mantle.product.Product" in-map="[productId:variantProductId, productName:variant.title]"/>
            </then><else>
                <service-call name="create#mantle.product.Product" in-map="[
                    productName:variant.title, productTypeEnumId:'PtAsset', assetTypeEnumId:'AstTpInventory', ownerPartyId:ownerPartyId, ownerPartyId:ownerPartyId]" out-map="variantContext"/>
                <set field="variantProductId" from="variantContext.productId"/>

                <service-call name="create#mantle.product.ProductAssoc" in-map="[
                    productId:productId, toProductId:variantProductId, productAssocTypeEnumId:'PatVariant', fromDate:ec.user.nowTimestamp]"/>

                <service-call name="create#mantle.product.ProductIdentification" in-map="[
                    productId:variantProductId, productIdTypeEnumId:'PidtShopify', idValue:variant.id]"/>

                <service-call name="create#mantle.product.ProductIdentification" out-map="context" in-map="[
                    productId:variantProductId, productIdTypeEnumId:'PidtInventoryItemShopify', idValue:variant.inventory_item_id]"/>
            </else></if>

            <!-- The variant.option1 needs to have been previously listed/created with the virtual product -->
            <set field="productFeatureId" from="mapOptionToFeature[variant.option1]"/>

            <service-call name="mantle.product.ProductServices.apply#ProductFeatures"
                in-map="[productId:variantProductId, productFeatureIdList:[productFeatureId], applTypeEnumId:'PfatStandard',
                    fromDate:ec.user.nowTimestamp, sequenceNum:variant.position]"/>

            <if condition="variant.option2">
                <set field="productFeatureId" from="mapOptionToFeature[variant.option2]"/>
                <service-call name="mantle.product.ProductServices.apply#ProductFeatures"
                    in-map="[productId:variantProductId, productFeatureIdList:[productFeatureId], applTypeEnumId:'PfatStandard',
                    fromDate:ec.user.nowTimestamp, sequenceNum:variant.position]"/>
            </if>

            <if condition="variant.option3">
                <set field="productFeatureId" from="mapOptionToFeature[variant.option3]"/>
                <service-call name="mantle.product.ProductServices.apply#ProductFeatures"
                    in-map="[productId:variantProductId, productFeatureIdList:[productFeatureId], applTypeEnumId:'PfatStandard',
                    fromDate:ec.user.nowTimestamp, sequenceNum:variant.position]"/>
            </if>

            <if condition="variant.weight &amp;&amp; variant.weight_unit">
                <service-call name="mantle.shopify.ShopifyProductServices.create#ShopifyWeight" in-map="[
                    productId:variantProductId, weight:variant.weight, unit:variant.weight_unit]"/>
            </if>

            <if condition="variant.price">
                <service-call name="mantle.shopify.ShopifyProductServices.create#ShopifyPrice" in-map="[
                    productStoreId:productStoreId, productId:variantProductId, amount:variant.price]"/>
            </if>

            <!-- optional property on the shopify object -->
            <iterate list="variant.presentment_prices" entry="price">
                <service-call name="mantle.shopify.ShopifyProductServices.create#ShopifyPrice" in-map="[
                    productStoreId:productStoreId, productId:variantProductId, currency:price.currency, amount:price.amount]"/>
            </iterate>

            <!-- If inventory is managed by Moqui, we would not process this value from Shopify -->
            <if condition="variant.inventory_management == 'shopify'">
                <!--service-call name="mantle.product.AssetServices.record#PhysicalInventoryQuantity" out-map="assetOut"
                        in-map="[productId:variantProductId, facilityId:inventoryFacilityId, 
                            ownerPartyId:ownerPartyId, statusId:'AstAvailable', quantity:variant.inventory_quantity]" async="true"/-->
            </if>
        </actions>
    </service>

    <service verb="create" noun="ShopifyWeight">
        <in-parameters>
            <parameter name="productId" required="true"/>
            <parameter name="weight" required="true"/>
            <parameter name="unit" required="true"/>
        </in-parameters>
        <actions>
            <entity-find-one entity-name="moqui.basic.Uom" value-field="weightUom">
                <field-map field-name="uomTypeEnumId" value="UT_WEIGHT_MEASURE"/>
                <field-map field-name="abbreviation" from="unit"/>
            </entity-find-one>

            <entity-find-one entity-name="mantle.product.ProductDimension" value-field="dimension">
                <field-map field-name="dimensionTypeId" value="ShippingWeight"/>
                <field-map field-name="valueUomId" from="weightUom.uomId"/>
            </entity-find-one>

            <if condition="dimension">
                <return /><!-- weight found, do nothing -->
            </if>

            <service-call name="create#mantle.product.ProductDimension" in-map="[
                productId:productId, dimensionTypeId:'ShippingWeight', valueUomId:weightUom.uomId, value:weight]"/>
        </actions>
    </service>

    <service verb="create" noun="ShopifyPrice">
        <in-parameters>
            <parameter name="productStoreId" required="true"/>
            <parameter name="productId" required="true"/>
            <parameter name="currency" default-value="USD"/>
            <parameter name="amount" type="BigDecimal" required="true"/>
        </in-parameters>
        <actions>
            <entity-find-one entity-name="moqui.basic.Uom" value-field="priceUom">
                <field-map field-name="uomTypeEnumId" value="UT_CURRENCY_MEASURE"/>
                <field-map field-name="abbreviation" from="currency"/>
            </entity-find-one>

            <entity-find entity-name="mantle.product.ProductPrice" list="existingPrices" for-update="true">
                <econdition field-name="priceTypeEnumId" value="PptCurrent"/>
                <econdition field-name="pricePurposeEnumId" value="PppPurchase"/>
                <econdition field-name="productStoreId" from="productStoreId"/>
                <econdition field-name="priceUomId" from="priceUom.uomId"/>
                <date-filter />
            </entity-find>

            <if condition="existingPrices">
                <iterate list="existingPrices" entry="existingPrice">
                    <if condition="existingPrice.price == amount">
                        <return /><!-- identical price found, do nothing -->
                    </if>
                    <!-- different price found, expire this, create new -->
                    <set field="existingPrice.thruDate" from="ec.user.nowTimestamp"/>
                    <entity-update value-field="existingPrice"/>
                </iterate>
            </if>

            <service-call name="create#mantle.product.ProductPrice" in-map="[
                priceTypeEnumId:'PptCurrent', pricePurposeEnumId:'PppPurchase', productStoreId:productStoreId, productId:productId, priceUomId:priceUom.uomId, price:amount, fromDate:ec.user.nowTimestamp]"/>
        </actions>
    </service>

    <service verb="upload" noun="MoquiStoreProducts">
        <in-parameters>
            <parameter name="systemMessageRemoteId" required="true"/>
        </in-parameters>
        <out-parameters>
            <parameter name="productIdList"/>
        </out-parameters>
        <actions>
            <entity-find-one entity-name="moqui.service.message.SystemMessageRemote" value-field="remote" />
            <if condition="!remote"><return error="true" message="No Remote found for ID ${systemMessageRemoteId}"/></if>

            <!-- get all the categories for this store -->
            <service-call name="mantle.shopify.ShopifyProductServices.get#ProductStoreCategories"
                    in-map="[productStoreId:remote.productStoreId]" out-map="context"/>

            <!-- get all the memberships to the categories -->
            <entity-find entity-name="mantle.product.category.ProductCategoryMember" list="pcmList"><date-filter />
                <econdition field-name="productCategoryId" operator="in" from="productCategoryIdList"/></entity-find>

            <!-- get a unique list of productIds based on those memberships -->
            <set field="productIdList" from="pcmList.productId.unique( false )"/>

            <iterate list="productIdList" entry="productId">
                <service-call name="mantle.shopify.ShopifyProductServices.upload#MoquiProduct"
                    in-map="[systemMessageRemoteId:systemMessageRemoteId, productId:productId]"/>
            </iterate>
        </actions>
    </service>

    <service verb="upload" noun="MoquiProduct">
        <in-parameters>
            <parameter name="systemMessageRemoteId" required="true"/>
            <parameter name="productId" required="true"/>
        </in-parameters>
        <actions>
            <entity-find-one entity-name="moqui.service.message.SystemMessageRemote" value-field="remote" />

            <entity-find-one entity-name="mantle.product.ProductIdentification" value-field="shopifyIdentification">
                <field-map field-name="productIdTypeEnumId" value="PidtShopify"/>
                <field-map field-name="productId"/></entity-find-one>

            <service-call name="mantle.shopify.ApiServices.get#ProductData" 
                      in-map="[productId:productId, productStoreId:remote.productStoreId]"
                      out-map="context" />

            <if condition="shopifyIdentification">
                <set field="productData.id" from="shopifyIdentification.idValue"/>
            </if>

            <set field="apiResponse" value="[:]"/>
            <script><![CDATA[
                String method = shopifyIdentification ? 'PUT' : 'POST';
                org.moqui.util.RestClient restClient = ec.service.rest().method(method)
                    .addHeader("Content-Type", "application/json")
                    .jsonObject(groovy.json.JsonOutput.toJson([product: productData]))
                    .basicAuth(remote.username, remote.password)
                    .uri(ec.resource.expand(remote.sendUrl, "", [resource:"products"]));

                org.moqui.util.RestClient.RestResponse restResponse = restClient.call()

                if (restResponse.statusCode != 201) {
                    ec.message.addError("Shopify Products API Error ${restResponse.statusCode} ${restResponse.reasonPhrase}: ${restResponse.text()}")
                    return;
                }
                apiResponse = new groovy.json.JsonSlurper().parseText(restResponse.text());
            ]]></script>
            <log message="apiResponse: ${apiResponse}"/>
            <set field="shopifyVariants" from="apiResponse.product.variants"/>

            <if condition="!shopifyIdentification">
                <service-call name="create#mantle.product.ProductIdentification" out-map="context" 
                    in-map="[productId:productId, productIdTypeEnumId:'PidtShopify', idValue: apiResponse.product.id]"/>

                <!-- if the moqui product had no variants, then we use the inventory item from the auto-created shopify variant -->
                <if condition="!productData.variants &amp;&amp; shopifyVariants">
                    <service-call name="create#mantle.product.ProductIdentification" out-map="context" 
                        in-map="[productId:productId, productIdTypeEnumId:'PidtInventoryItemShopify', idValue:shopifyVariants[0].inventory_item_id]"/>
                </if>
            </if>

            <if condition="shopifyVariants">
                <iterate list="shopifyVariants" entry="variant">
                    <!-- the only way to match the response to the request is via the options -->
                    <set field="moquiProductId" from="productData.variants.find({it.option1 == variant.option1 
                                                                      &amp;&amp; it.option2 == variant.option2 
                                                                      &amp;&amp; it.option3 == variant.option3})?.moquiProductId"/>
                    <if condition="!moquiProductId">
                        <continue/>
                    </if>

                    <entity-find-one entity-name="mantle.product.ProductIdentification" value-field="variantIdentification">
                        <field-map field-name="productIdTypeEnumId" value="PidtShopify"/>
                        <field-map field-name="productId"/></entity-find-one>
                    <if condition="variantIdentification">
                        <!-- identification already created for this variant, ignoring -->
                        <continue/>
                    </if>

                    <service-call name="create#mantle.product.ProductIdentification" out-map="context" 
                        in-map="[productId:moquiProductId, productIdTypeEnumId:'PidtShopify', idValue:variant.id]"/>
                    <service-call name="create#mantle.product.ProductIdentification" out-map="context" 
                        in-map="[productId:moquiProductId, productIdTypeEnumId:'PidtInventoryItemShopify', idValue:variant.inventory_item_id]"/>
                </iterate>
            </if>
        </actions>
    </service>

    <!-- 
        Endpoint to pull down products from Shopify.

        https://{store_name}.myshopify.com/admin/api/2023-04/custom_collections.json?limit={limit}
    -->
    <service verb="download" noun="ShopifyCollections">
        <in-parameters>
            <parameter name="systemMessageRemoteId" required="true"/>
            <parameter name="limit" default-value="250"/>
        </in-parameters>
        <out-parameters>
            <parameter name="productCategoryIdList"/>
        </out-parameters>
        <actions>
            <script>import groovy.json.JsonSlurper</script>
            <entity-find-one entity-name="moqui.service.message.SystemMessageRemote" value-field="remote" />
            <if condition="!remote"><return error="true" message="No Remote of type 'ShopifySystemMessageType' found for ID ${systemMessageRemoteId}"/></if>
            <entity-find-related-one relationship-name="mantle.product.store.ProductStore" value-field="remote" to-value-field="productStore"/>
            <if condition="!productStore"><return error="true" message="No ProductStore configured for remote ID ${systemMessageRemoteId}"/></if>

            <!-- get the browse root for this store, this is needed to store the new categories under -->
            <entity-find entity-name="mantle.product.store.ProductStoreCategory" list="pscList">
                <econdition field-name="storeCategoryTypeEnumId" value="PsctBrowseRoot"/>
                <econdition field-name="productStoreId" from="remote.productStoreId"/><date-filter /></entity-find>
            <if condition="!pscList"><return error="true" message="No Browse Root Category found for Store ID ${productStoreId}"/></if>
            <set field="browseRootCategoryid" from="pscList.first().productCategoryId"/>

            <set field="apiResponse" from="[:]"/>
            <script><![CDATA[
                String collectionsUrl = ec.resource.expand(remote.sendUrl, "", [resource:"custom_collections"]) + "?limit=${limit}";

                org.moqui.util.RestClient collectionsRestClient = ec.service.rest().method("GET")
                    .addHeader("Content-Type", "application/json")
                    .basicAuth(remote.username, remote.password)
                    .uri(collectionsUrl);

                org.moqui.util.RestClient.RestResponse collectionsRestResponse = collectionsRestClient.call()

                if (collectionsRestResponse.statusCode != 200) {
                    String apiError = "${collectionsRestResponse.statusCode} ${collectionsRestResponse.reasonPhrase}: ${collectionsRestResponse.text()}"
                } else {
                    apiResponse = new groovy.json.JsonSlurper().parseText(collectionsRestResponse.text());
                }
            ]]></script>
            <if condition="apiError">
                <return error="true" message="Shopify Collections API Error ${apiError}"/>
            </if>
            <set field="productCategoryIdList" from="[]"/>
            <iterate list="apiResponse.custom_collections" entry="collection">
                <entity-find-one entity-name="mantle.product.category.ProductCategory" value-field="category">
                    <field-map field-name="pseudoId" from="collection.id"/></entity-find-one>

                <if condition="category"><then>
                    <set field="productCategoryId" from="category.productCategoryId"/>
                    <set field="category.categoryName" from="collection.title"/>
                    <set field="category.description" from="collection.body_html"/>
                    <entity-update value-field="category"/>
                </then><else>
                    <service-call name="create#mantle.product.category.ProductCategory" out-map="context"
                        in-map="[productCategoryTypeEnumId:'PctCatalog', pseudoId:collection.id, categoryName:collection.title, description:collection.body_html, ownerPartyId:productStore.organizationPartyId]"/>

                    <service-call name="create#mantle.product.category.ProductCategoryRollup" out-map="context"
                        in-map="[productCategoryId:productCategoryId, parentProductCategoryId:browseRootCategoryid, fromDate:collection.published_at]"/>
                </else></if>

                <set field="apiResponse" value="[:]"/>
                <script><![CDATA[
                    String collectsUrl = ec.resource.expand(remote.sendUrl, "", [resource:"collects"]) + "?collection_id=${collection.id}";

                    org.moqui.util.RestClient collectsRestClient = ec.service.rest().method("GET")
                        .addHeader("Content-Type", "application/json").basicAuth(remote.username, remote.password).uri(collectsUrl);

                    org.moqui.util.RestClient.RestResponse collectsRestResponse = collectsRestClient.call()
                    if (collectsRestResponse.statusCode != 200) {
                        apiError = "${collectsRestResponse.statusCode} ${collectsRestResponse.reasonPhrase}: ${collectsRestResponse.text()}"
                    } else {
                        apiResponse = new groovy.json.JsonSlurper().parseText(collectsRestResponse.text());
                    }
                ]]></script>
                <if condition="apiError">
                    <return error="Shopify Collecs API Error ${apiError}"/>
                </if>

                <iterate list="apiResponse.collects" entry="collect">
                    <!-- get the moquiId id of this shopifyId -->
                    <entity-find-one entity-name="mantle.product.ProductIdentification" value-field="shopifyId">
                        <field-map field-name="productIdTypeEnumId" value="PidtShopify"/>
                        <field-map field-name="idValue" from="collect.product_id"/></entity-find-one>

                    <if condition="!shopifyId">
                        <return error="true" message="The Shopify product_id: ${collect.product_id} is not linked with a moqui product, please download the products first calling download#ShopifyProducts" />
                    </if>
                    <entity-find entity-name="mantle.product.category.ProductCategoryMember" list="pcmList">
                        <econdition field-name="productId" from="shopifyId.productId"/>
                        <econdition field-name="productCategoryId"/><date-filter/></entity-find>

                    <if condition="!pcmList">
                        <service-call name="create#mantle.product.category.ProductCategoryMember" out-map="context"
                            in-map="[productCategoryId:productCategoryId, productId:shopifyId.productId, 
                            fromDate:collection.created_at ?: ec.user.nowTimestamp]"/>
                    </if>
                </iterate>
                <set field="productCategoryIdList" from="productCategoryIdList.plus(productCategoryId)"/>
            </iterate>
        </actions>
    </service>

    <service verb="upload" noun="MoquiStoreCategories">
        <in-parameters>
            <parameter name="systemMessageRemoteId" required="true"/>
        </in-parameters>
        <out-parameters>
            <parameter name="productCategoryIdList"/>
        </out-parameters>
        <actions>
            <entity-find-one entity-name="moqui.service.message.SystemMessageRemote" value-field="remote" />
            <if condition="!remote"><return error="true" message="No Remote found for ID ${systemMessageRemoteId}"/></if>

            <!-- get the browse root for this store -->
            <entity-find entity-name="mantle.product.store.ProductStoreCategory" list="pscList">
                <econdition field-name="storeCategoryTypeEnumId" value="PsctBrowseRoot"/>
                <econdition field-name="productStoreId" from="remote.productStoreId"/><date-filter /></entity-find>
            <if condition="!pscList"><return error="true" message="No Browse Root Category found for Store ID ${productStoreId}"/></if>

            <!-- We get all the categories under the browse root recursively -->
            <service-call name="mantle.shopify.ShopifyProductServices.populate#CategoriesRecursive" out-map="context"
                in-map="[parentProductCategoryId:pscList.first().productCategoryId]"/>

            <iterate list="productCategoryIdList" entry="productCategoryId">
                <service-call name="mantle.shopify.ShopifyProductServices.upload#MoquiCategory"
                    in-map="[systemMessageRemoteId:systemMessageRemoteId, productCategoryId:productCategoryId]"/>
            </iterate>
        </actions>
    </service>

    <service verb="upload" noun="MoquiCategory">
        <in-parameters>
            <parameter name="systemMessageRemoteId" required="true"/>
            <parameter name="productCategoryId" required="true"/>
        </in-parameters>
        <actions>
            <entity-find-one entity-name="moqui.service.message.SystemMessageRemote" value-field="remote"/>
            <entity-find-one entity-name="mantle.product.category.ProductCategory" value-field="category" for-update="true"/>

            <set field="apiResponse" value="[:]"/>

            <!-- get all the products assigned to these categories -->
            <entity-find entity-name="mantle.product.category.ProductCategoryMember" list="pcmList">
                <econdition field-name="productCategoryId"/><date-filter /></entity-find>

            <!-- get the shopiify ids of those products -->
            <entity-find entity-name="mantle.product.ProductIdentification" list="pidList">
                <econdition field-name="productId" operator="in" from="pcmList.productId"/>
                <econdition field-name="productIdTypeEnumId" value="PidtShopify"/>
            </entity-find>

            <set field="existingCollects" from="[]"/>

            <!-- if the pseudoId is not the same as productCategoryId, we think it was populated with custom_collection.id from Shopify -->
            <if condition="category.pseudoId != category.productCategoryId">
                <script><![CDATA[
                    String url = ec.resource.expand(remote.sendUrl, '', [resource:'collects']) + '?collection_id=' + category.pseudoId;
                    org.moqui.util.RestClient.RestResponse restResponse = ec.service.rest().method('GET')
                        .basicAuth(remote.username, remote.password).uri(url).call();

                    if (restResponse.statusCode != 200) {
                        ec.message.addError("Shopify custom_collection API Error ${restResponse.statusCode} ${restResponse.reasonPhrase}: ${restResponse.text()}, possibly the pseudoId for Product Category ${productCategoryId} was not Shopify custom_collection.id");
                        return;
                    }
                    apiResponse = new groovy.json.JsonSlurper().parseText(restResponse.text());
                ]]></script>
                <set field="existingCollects" from="apiResponse.collects.product_id"/>
            </if>

            <set field="collects" from="[]"/>
            <iterate list="pidList" entry="pid">
                <if condition="existingCollects.find({it.toString() == pid.idValue})">
                    <log message="product_id: ${pid.idValue} already exists on collection, skipping"/>
                    <continue/>
                </if>
                <set field="collects" from="collects.plus([product_id:pid.idValue])"/>
            </iterate>
            
            <set field="custom_collection" from="[:]"/>
            <set field="custom_collection.title" from="category.categoryName"/>
            <set field="custom_collection.collects" from="collects"/>
            
            <script><![CDATA[
                String method = category.pseudoId == category.productCategoryId ? 'POST' : 'PUT';
                String resource = category.pseudoId == category.productCategoryId ? 'custom_collections' : 'custom_collections/'+category.pseudoId;

                org.moqui.util.RestClient.RestResponse restResponse = ec.service.rest().method(method)
                    .addHeader("Content-Type", "application/json").basicAuth(remote.username, remote.password)
                    .jsonObject(groovy.json.JsonOutput.toJson([custom_collection: custom_collection]))
                    .uri(ec.resource.expand(remote.sendUrl, "", [resource:resource])).call();

                if (restResponse.statusCode != 200) {
                    ec.message.addError("Shopify custom_collection API Error ${restResponse.statusCode} ${restResponse.reasonPhrase}: ${restResponse.text()}");
                    return;
                }
                apiResponse = new groovy.json.JsonSlurper().parseText(restResponse.text());
            ]]></script>
            <if condition="!apiResponse.custom_collection.id">
                <return error="No custom_collection ID on API Response ${restResponse.text()}"/>
            </if>
            <set field="category.pseudoId" from="apiResponse.custom_collection.id"/>
            <entity-update value-field="category"/>
        </actions>
    </service>

    <service verb="get" noun="ProductStoreCategories">
        <in-parameters>
            <parameter name="productStoreId" required="true"/>
            <parameter name="storeCategoryTypeEnumId"/>
        </in-parameters>
        <out-parameters>
            <parameter name="productCategoryIdList"/>
        </out-parameters>
        <actions>
            <!-- Get just the browse root for this store -->
            <entity-find entity-name="mantle.product.store.ProductStoreCategory" list="pscList">
                <econdition field-name="storeCategoryTypeEnumId" operator="in" ignore-if-empty="true"/>
                <econdition field-name="productStoreId"/><date-filter /></entity-find>

            <set field="productCategoryIdList" from="[]"/>
            <iterate list="pscList" entry="psc">
                <set field="productCategoryIdList" from="productCategoryIdList.plus(psc.productCategoryId)"/>
                <service-call name="mantle.shopify.ShopifyProductServices.populate#CategoriesRecursive" out-map="context"
                    in-map="[parentProductCategoryId:psc.productCategoryId, productCategoryIdList:productCategoryIdList]"/>
            </iterate>
        </actions>
    </service>

    <service verb="populate" noun="CategoriesRecursive">
        <in-parameters>
            <parameter name="parentProductCategoryId" required="true"/>
            <parameter name="productCategoryIdList" type="List"/>
        </in-parameters>
        <out-parameters>
            <parameter name="productCategoryIdList"/>
        </out-parameters>
        <actions>
            <!-- get all the child category rollups -->
            <entity-find entity-name="mantle.product.category.ProductCategoryRollup" list="rollupList">
                <econdition field-name="parentProductCategoryId"/><date-filter /></entity-find>

            <iterate list="rollupList" entry="rollup">
                <!-- check if this category has already been included in the productCategoryIdList List -->
                <if condition="productCategoryIdList.find({it == rollup.productCategoryId})">
                     <log message="Category ID ${rollup.productCategoryId} previously added, skipping"/>
                     <continue/>
                </if>
                <set field="productCategoryIdList" from="productCategoryIdList ? productCategoryIdList.plus(rollup.productCategoryId) : [rollup.productCategoryId]"/>

                <service-call name="mantle.shopify.ShopifyProductServices.populate#CategoriesRecursive" out-map="context"
                    in-map="[parentProductCategoryId:rollup.productCategoryId, productCategoryIdList:productCategoryIdList]"/>
            </iterate>
        </actions>
    </service>


    <service verb="queue" noun="ProductInventory">
        <in-parameters>
            <parameter name="productId" required="true"/>
            <parameter name="facilityId" required="true"/>
        </in-parameters>
        <out-parameters>
            <parameter name="productCategoryIdList"/>
        </out-parameters>
        <actions>
            <entity-find-one entity-name="mantle.product.ProductIdentification" value-field="productPidt">
                <field-map field-name="productIdTypeEnumId" value="PidtInventoryItemShopify"/>
                <field-map field-name="productId"/></entity-find-one>

            <if condition="!productPidt">
                <log message="Product ID: ${productId} not identified in Shopify, ignoring"/>
                <return/>
            </if>

            <!-- get the product stores that relate to this facility -->
            <entity-find entity-name="mantle.product.store.ProductStoreFacility" list="stores">
                <econdition field-name="facilityId"/><date-filter /></entity-find>

            <!-- check if this product is managed by any Shopify remotes -->
            <entity-find entity-name="moqui.service.message.SystemMessageRemote" list="remotes">
                <econdition field-name="productStoreId" operator="in" from="stores.productStoreId"/>
                <econdition field-name="systemMessageTypeId" value="ShopifySystemMessageType"/></entity-find>

            <if condition="!remotes">
                <log message="Facility ID: ${facilityId} not managed by any Shopfiy remotes, ignoring"/>
                <return/>
            </if>

            <service-call name="mantle.product.AssetServices.get#AvailableInventory" in-map="context" out-map="context"/>
            <entity-find-one entity-name="mantle.shopify.ProductInventoryQueue" value-field="queuedInventory" for-update="true"/>

            <if condition="!queuedInventory"><then>
                <service-call name="create#mantle.shopify.ProductInventoryQueue" 
                    in-map="context + [availableToPromise:availableToPromiseTotal, inventoryItemId:productPidt.idValue]"/>
            </then><else-if condition="queuedInventory.availableToPromise != availableToPromiseTotal">
                <set field="queuedInventory.availableToPromise" from="availableToPromiseTotal"/>
                <entity-update value-field="queuedInventory"/>
            </else-if></if>
        </actions>
    </service>

    <service verb="upload" noun="ProductInventoryQueue">
        <in-parameters>
            <parameter name="systemMessageRemoteId" required="true"/>
            <parameter name="limit" default-value="250">The limit per facility connected to the store on the Remote</parameter>
        </in-parameters>
        <actions>
            <entity-find-one entity-name="moqui.service.message.SystemMessageRemote" value-field="remote">
                <field-map field-name="systemMessageTypeId" value="ShopifySystemMessageType"/>
                <field-map field-name="systemMessageRemoteId"/>
            </entity-find-one>

            <entity-find entity-name="mantle.product.store.ProductStoreFacility" list="storeFaclities">
                <econdition field-name="productStoreId" from="remote.productStoreId"/><date-filter /></entity-find>

            <iterate list="storeFacilities" entry="storeFacility">
                <entity-find-one entity-name="mantle.facility.Facility" value-field="facility">
                    <field-map field-name="facilityId" from="storeFacility.facilityId"/></entity-find-one>

                <!-- get all the queued inventory updates for this facility -->
                <entity-find entity-name="mantle.shopify.ProductInventoryQueue" limit="limit" list="productInventoryQueue">
                    <econdition field-name="facilityId" from="storeFacility.facilityId"/><date-filter /></entity-find>

                <iterate list="productInventoryQueue" entry="productInventory">
                    <set field="inventory" from="[
                        location_id:facility.externalId,
                        inventory_item_id:productInventory.inventoryItemId,
                        available:productInventory.availableToPromise
                    ]"/>
                    <script><![CDATA[
                        String url = ec.resource.expand(remote.sendUrl, "", [resource:'inventory_levels/set']);

                        org.moqui.util.RestClient.RestResponse restResponse = ec.service.rest().method('POST')
                            .addHeader("X-Shopify-Access-Token", remote.password).addHeader("Content-Type", "application/json")
                            .jsonObject(groovy.json.JsonOutput.toJson(inventory)).uri(url).call();

                        if (restResponse.statusCode != 200) {
                            ec.message.addError("Shopify inventory_levels/set API Error ${restResponse.statusCode} ${restResponse.reasonPhrase}: ${restResponse.text()}");
                        }
                    ]]></script>
                </iterate>
            </iterate>
        </actions>
    </service>
</services>